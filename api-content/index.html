{"posts":[{"title":"题解：AcWing 85.不用加减乘除做加法","content":"题目链接 AcWing 85.不用加减乘除做加法 引用 简单看了一下大佬们的题解，真的是操了，一堆骚操作，完全不懂2333，有用low_bit+异或+与实现的，也有和y总一样的异或+与。对比了大佬的题解发现一些细节方面的问题，等会待我一一道来。全加器感兴趣的小伙伴也可以去了解一下，慕明大佬写的题解用到了low_bit算法也可以观摩一下，加深对位运算的理解，对以后做题有意想不到的帮助哦 慕明 AcWing 85. 不用加减乘除做加法 lowbit操作 咲张熊猫人 AcWing 85. 不用加减乘除做加法 Elpsy_3 AcWing 85. 不用加减乘除做加法 C++ 最简单易懂的思路 GRID AcWing 85. 不用加减乘除做加法 全加器，位运算，C++ cornerCao AcWing 85. 不用加减乘除做加法 贺谦 AcWing 85. 不用加减乘除做加法 题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。 样例 输入：num1 = 1 , num2 = 2 输出：3 算法 (位运算) O(1)O(1)O(1) 异或 相同为0，不同为1，所以可以起到相加的作用 与 同为1为1，其余为0，起到了进位作用 因为不能使用加减乘除运算，所以我们只能用位运算来实现，因为计算机中的任何运算最终都是位运算来完成的。 那么应该怎么做呢？ 加法一共分成两步，首先按位相加，其次再处理进位。 聪明的小伙伴应该发现了异或运算的结果其实相当于两个二进制数相加，但没有进位，那么如果进位的话怎么办呢，那些大佬已经帮我们解决了这一问题，进位的话只要将这两个数相与然后右移1位就行了，不断迭代，直到进位为0，因为与的结果迟早是0，而右移的结果也迟早是0。这样我们就解决了进位与不进位的处理方式。只要进位为0，那么我们的计算就停止 时间复杂度 O(1)O(1)O(1) 最多计算32次，所以时间复杂度是 O(1)O(1)O(1) 的 C++ 代码 class Solution { public: int add(int num1, int num2){ while (num2) { //可以把num2想象为进位，每次迭代时异或这两个数就是让他们直接相加不进位，然后再处理进位，接着再相加 int sum = num1 ^ num2; int carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum, num2 = carry; } return num1; } }; ","link":"https://solitudealma.github.io/post/AcWing85/"},{"title":"题解：LeetCode 191.位1的个数","content":"题目链接 leetcode 191.位1的个数 引用 做法不唯一，引用一些大佬的解题方法，有助于我们更好的理解位运算的操作，如果需要用到这个数可以用右移k位与1这个方法，其余的没差 我要出去乱说 LeetCode 191. 位1的个数（遍历法、lowbit法） Ncik LeetCode 191. 位1的个数 开水白菜 LeetCode 191. 二进制位1的个数 题目描述 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的示例3中，输入表示有符号整数 -3。 样例 输入样例 00000000000000000000000000001011 输出样例 3 解释 输入的二进制串 00000000000000000000000000001011中，共有三位为 '1'。 输入样例 00000000000000000000000010000000 输出样例 1 解释 输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 输入样例 11111111111111111111111111111101 输出 31 解释 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 算法1 (暴力枚举) O(1)O(1)O(1) 利用右移运算和与运算可以轻松算出32位unsigned int 的二进制表示中的1的个数 时间复杂度 O(1)O(1)O(1) 函数只有一重循环，而且还是常数级别的，所以时间复杂度是 O(1)O(1)O(1) 的 C++ 代码 class Solution { public: int hammingWeight(uint32_t n) { int cnt = 0; for(int i = 0; i &lt; 32; i++) if(n &gt;&gt; i &amp; 1) cnt ++; //或者不需要判断，直接相加即可，与的结果只有0和1，加个判断会稍微慢一点，无伤大雅 return cnt; } }; 算法2 (low_bit) O(1)O(1)O(1) 一个数与上它的负数可以得到它的二进制表示的最后一位1的位置，比如4的二进制表示是 0000 0000 0000 0000 0000 0000 0000 1000 ，负数在计算机中以补码的形式存在，所以-4的二进制表示是 1111 1111 1111 1111 1111 1111 1111 1000 ，然后进行与运算得到的是 0000 0000 0000 0000 0000 0000 0000 1000 也就是4，说明4的二进制表示的最后一位1是在4这个位置，所以如果我们用这个方法去计算一个数的二进制表示的1的个数，就可以用一个循环搞定，然后每次循环减去low_bit得到的数，只要这个数不为0就一直循环，比上一个算法快那么一点，因为它最多只循环32次，也就是每一位都有1 时间复杂度 O(1)O(1)O(1) 最多循环32次 C++ 代码 class Solution { public: int low_bit(uint32_t n) { return (n &amp; (~n + 1)); } int hammingWeight(uint32_t n) { int cnt = 0; while(n) n -= low_bit(n) , cnt++; return cnt; } }; ","link":"https://solitudealma.github.io/post/LeetCode191/"},{"title":"题解：AcWing 1236.递增三元组","content":"题目链接 AcWing 1236.递增三元组 引用 z林深时见鹿 AcWing 1236. 递增三元组( 二分解法 ) macat AcWing 1236. 递增三元组 (二分+双指针+前缀和) 冷丁Hacker AcWing 1236. 递增三元组(求赞谢谢兄弟) 田所浩二 AcWing 1236. 递增三元组(模板二分的应用） 小呆呆 AcWing 1236. 递增三元组 题目描述 给定三个整数数组 A=[A1,A2,…AN], B=[B1,B2,…BN], C=[C1,C2,…CN], 请你统计有多少个三元组 (i,j,k) 满足： 1≤i,j,k≤N1≤i,j,k≤N1≤i,j,k≤N Ai&lt;Bj&lt;CkA_i&lt;B_j&lt;C_kAi​&lt;Bj​&lt;Ck​ 样例 输入格式 第一行包含一个整数 N。 第二行包含 N 个整数 A1,A2,…AN。 第三行包含 N 个整数 B1,B2,…BN。 第四行包含 N 个整数 C1,C2,…CN。 输出格式 一个整数表示答案。 数据范围 1≤N≤105,1≤N≤105,1≤N≤105, 0≤Ai,Bi,Ci≤1050≤A_i,B_i,C_i≤1050≤Ai​,Bi​,Ci​≤105 输入样例： 3 1 1 1 2 2 2 3 3 3 输出样例： 27 算法1 (前缀和) O(n)O(n)O(n) 因为我们分别从A，B，C中取出一个数，构成 Ai&lt;Bj&lt;CkA_i &lt; B_j &lt; C_kAi​&lt;Bj​&lt;Ck​ ，如果只是单纯的朴素算法（暴力），那么就是 O(n3)O(n^3)O(n3) 的时间复杂度必定超时。那么能不能找出其中的关系呢 其实细心的你肯定发现了 BjB_jBj​ 作为中间数字和其他两位数的关系，我们只要找出A中有多少了数小于当前的B，C中有多少个数大于B，最后相乘累加即可，相乘是因为排列问题 前缀和：当y总说出可以用前缀和方法做的时候我还在疑惑该怎么做，被他这么一讲，好像对于前缀和又有了新的认识，之前只是停留在对于数组的前缀和计算，但是这题用到的不是数组本身的前缀和，而是数组中的数在这个数组里出现次数的前缀和 怎么理解呢？我们计算A、C中数字出现的次数，然后对他们两个求前缀和，接着只要枚举B，算一下A中小于 BjB_jBj​ 的数的个数和C中大于 CkC_kCk​ 的数的个数的乘积，然后累加就行 时间复杂度 O(n)O(n)O(n) 前缀和的时间复杂度是 O(n)O(n)O(n) C++ 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int N = 1e5 + 10; int n; int a[N] , b[N] , c[N]; int as[N] , cs[N]; int cnt[N] , s[N]; int main() { scanf(&quot;%d&quot; , &amp;n); //因为数据范围是从零开始，计算前缀和时我们习惯下标从1开始，所以数组中的数都往前移 for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;a[i]) , a[i] ++; for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;b[i]) , b[i] ++; for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;c[i]) , c[i] ++; //计算as[] for(int i = 0; i &lt; n; i ++) cnt[a[i]] ++; for(int i = 1; i &lt; N; i ++) s[i] = s[i - 1] + cnt[i]; //b[i]- 1是因为b增加了1 for(int i = 0; i &lt; n; i ++) as[i] = s[b[i] - 1]; //清空cnt[] 和 s[] memset(cnt , 0 , sizeof cnt); memset(s , 0 , sizeof s); //计算过cs[] for(int i = 0; i &lt; n; i ++) cnt[c[i]] ++; for(int i = 1; i &lt; N; i ++) s[i] = s[i - 1] + cnt[i]; //本来b[i]应该减1，但是因为已经加过了，就不需要了，s[N - 1] - s[b[i]] ==&gt; s[r] - s[l - 1] s[l ~ r] = s[r] - s[l - 1] for(int i = 0; i &lt; n; i ++) cs[i] = s[N - 1] - s[b[i]]; long long res = 0; for(int i = 0; i &lt; n; i ++) res += (long long)as[i] * cs[i]; printf(&quot;%lld&quot; , res); return 0; } 算法2 (sort+二分) O(nlogn)O(nlog_n)O(nlogn​) sort+二分：首先我们先将A、C数组排序，B排不排都无所谓。然后遍历B，二分找出A中小于 BjB_jBj​ 的数的下标，判断一下这个数是不是小于 BjB_jBj​ ，如果不是小于的话就说明A中最小的数都大于它，故小于 BjB_jBj​ 的数为零。同理对于C数组也一样，然后将得到的个数相乘再累加即可 时间复杂度 O(nlogn)O(nlog_n)O(nlogn​) sort+二分的时间复杂度是 O(nlogn)O(nlog_n)O(nlogn​) C++ 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n; int a[N] , b[N] , c[N]; int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;a[i]); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;b[i]); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;c[i]); sort(a , a + n) , sort(c , c + n); long long res = 0; for(int i = 0; i &lt; n; i ++) { int l = 0 , r = n - 1 , mid; long long x , y; while(l &lt; r) { mid = l + r + 1 &gt;&gt; 1; if(a[mid] &lt; b[i]) l = mid; else r = mid - 1; } if(a[l] &lt; b[i]) x = l + 1; else x = 0; l = 0 , r = n - 1; while(l &lt; r) { mid = l + r &gt;&gt; 1; if(c[mid] &gt; b[i]) r = mid; else l = mid + 1; } if(c[l] &gt; b[i]) y = n - l; else y = 0; res += x * y; } printf(&quot;%lld&quot; , res); return 0; } 算法3 (双指针) O(nlogn)O(nlog_n)O(nlogn​) 双指针：首先双指针算法运用的场景必须具备单调性，所以我们同二分一样要先排序，只不过查找的时候用双指针算法，因为查找最多是n次，所以整个算法的时间复杂度是 O(nlogn)O(nlog_n)O(nlogn​)，因为双指针是不回溯的，所以它的时间复杂度才会是 O(n)O(n)O(n)。因此我们计算时应该把三个数组都排序一遍，然后用两个变量计数就行了 时间复杂度 O(nlogn)O(nlog_n)O(nlogn​) 此时整个算法的时间复杂度是 O(nlogn)O(nlog_n)O(nlogn​) ⟺\\Longleftrightarrow⟺ O(n+nlogn)O(n + nlog_n)O(n+nlogn​) C++ 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n; int a[N] , b[N] , c[N]; int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;a[i]); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;b[i]); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;c[i]); sort(a , a + n) , sort(b , b + n) , sort(c , c + n); long long res = 0; //因为指针不能回溯，一旦回溯了时间复杂度就是n三方了，所以将变量定义在循环外 int j = 0 , k = 0; for(int i = 0; i &lt; n; i ++) { //指针停下来时一定在不满足条件的那个数上 while(j &lt; n &amp;&amp; a[j] &lt; b[i]) j ++; //取等号的原因是因为停下来的时候是不满足大于的，第k个数可能小于也可能等于，这样就会导致可能当前多算了一个，因此指针停下来时一定要在满足条件的那个数上，下一次的时候就能继续了 while(k &lt; n &amp;&amp; c[k] &lt;= b[i]) k ++; res += (long long) j * (n - k); } printf(&quot;%lld&quot; , res); return 0; } ","link":"https://solitudealma.github.io/post/AcWing1236/"},{"title":"对于kmp算法的一些理解以及模板的分享","content":"今天我们来讲一下kmp（看毛片）算法 讲到字符串操作有那些算法时，相信学过数据结构的小伙伴们都能想到kmp算法。 那么什么是kmp算法呢？从百度百科我们可以知道，kmp是三个人共同研究出来的一个算法，并以他们的名字命名。它的前身是Brute-Force算法，它有一个很大的缺点，那就是如果当前匹配失败那么指针往前移一位继续匹配。细心的小伙伴很容易就能发现匹配串越长的话本身就不容易匹配成功，那么你每次匹配失败指针只往前移动一位的话，其时间复杂度可想而知。那有没有什么更好的优化方式解决这一问题呢，kmp算法很好地解决了这一问题 初学kmp算法的小伙伴肯定会理解不来这个算法，其实这个算法还是不特别抽象并不是。当时我也是看了两三天才理解其中的奥秘。那废话不多说，我们就来看看这个kmp到底是怎么实现的吧 如果我们要了解kmp算法，那么我们应该先看看Brute-Force算法是怎么实现的，这个算法属于暴力算法。我们来看看具体怎么实现的吧 /* * * s为原串，p为模式串 * */ for(int i = 0; i &lt;= s.size() - p.size(); i ++) { bool flag = true; for(int j = 0; j &lt; p.size(); j ++) { if(p[j] != s[i + j]) { flag = false; break; } } if(flag) printf(&quot;pos : %d&quot; , i); } 从代码中我们可以发现这个算法的时间复杂度是 n∗mn*mn∗m 级别的，算法的实现不唯一，虽然这种写法看上去匹配失败时指针i并没有回退，但是我们要明白，两个字符串对比时，对应的指针是一直在改变的，如果匹配失败，那么指向原串s的指针就要指向本次匹配的第二个位置继续开始新的一次匹配，这样的话时间开销会非常大。 如果我们能够利用Brute-Force算法中的已知信息的话，那么我们是不是可以尝试优化呢，其实kmp算法巧妙地利用了最长前缀与后缀这一重要信息进行优化。 kmp算法的核心其实就是next数组的计算，也就是所谓的《部分匹配表》，里面存着前缀与后缀的最大相等长度。那何为前缀和后缀，前缀就是除第i个字符 p[i] 外的前i个字符组成的字串集合 ，后缀就是除第一个字符 p[1] 外，1-i中的字符组成的字串集合。部分匹配表 next[i] 存的就是i的前缀与后缀的最大公共元素（即最大共有元素的长度）。有了部分匹配表的话，在匹配失败时我们就知道到底需要往前回退多少就能继续往下匹配，而不是回退到本次匹配的下一个位置，这样就大大减少了匹配的时间开销。 那么我们来看看next数组是怎么计算的 // s[]是长文本，p[]是模式串，n是s的长度，m是p的长度，下标从1开始 求模式串的Next数组： for(int i = 2 , j = 0; i &lt;= m; i ++) { while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j ++; ne[i] = j; } 首先我们先手写一下部分匹配表的计算过程 以&quot;ABCDABD&quot;为例： － &quot;A&quot;的前缀和后缀都为空集，共有元素的长度为0； － &quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0； － &quot;ABC&quot;的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； － &quot;ABCD&quot;的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； － &quot;ABCDA&quot;的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为&quot;A&quot;，长度为1； － &quot;ABCDAB&quot;的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为&quot;AB&quot;，长度为2； － &quot;ABCDABD&quot;的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 if语句用于计数 next[i] 的值。由上述可以知道，如果 next[i - 1] 不为零，那么下一个位置是否出现新的字符，都可能导致 next[i] 为0（因为后缀一定会带上该字符）。所以我们计算时需要用到前面的匹配值进行回退，也就是while语句，如果当前j不为0并且匹配不相等时，往前退到与 next[j] 的值相等的位置（j回退），如果此时j不为0并且回退后 p[i] 依然不等于 p[j + 1]，那么就继续回退，直到j为0或者p[i] == p[j + 1] 为止。 简单来说就是p串自己与自己匹配，每次尝试 i 与 j+1 位的字符是否匹配，匹配的话 ne[i] 的值就是j的值（每次匹配时会检测j的值以及 p[i] 是否等于 p[j + 1] , 如果这两个条件同时满足，那么就需要回退，回退到当前j的 next[j] 上，如果next[j]不为0，那么是有可能存在前缀与后缀值相等，为0即第i位的next[i] = 0）。 例如：&quot;ABADABAC&quot; － &quot;A&quot;的前缀和后缀都为空集，共有元素的长度为0； － &quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0； － &quot;ABA&quot;的前缀为[A, AB]，后缀为[BA, A]，共有元素为&quot;A&quot;，共有元素的长度1； － &quot;ABAD&quot;的前缀为[A, AB, ABA]，后缀为[BAD, AD, D]，共有元素的长度为0； － &quot;ABADA&quot;的前缀为[A, AB, ABA, ABAD]，后缀为[BADA, ADA, DA, A]，共有元素为&quot;A&quot;，长度为1； － &quot;ABADAB&quot;的前缀为[A, AB, ABA, ABAD, ABADA]，后缀为[BADAB, ADAB, DAB, AB, B]，共有元素为&quot;AB&quot;，长度为2； － &quot;ABADABA&quot;的前缀为[A, AB, ABA, ABAD, ABADA, ABADAB]，后缀为[BADABA, ADABA, DABA, ABA, BA, A]，共有元素为&quot;ABA&quot;，共有元素的长度为3。 － &quot;ABADABAC&quot;的前缀为[A, AB, ABA, ABAD, ABADA, ABADAB, ABADABA]，后缀为[BADABAC, ADABAC, DABAC, ABAC, BAC, AC, C]，共有元素的长度为0。 上面这个例子，匹配最后一个字符的next[i]时，因为出现的字符导致 i 与 j + 1不匹配（此时i为8，j为3，next[j]为3），此时需要回退，回退到哪个位置由next[j]决定，当j为3时，它们依然不相等，所以最后 next[i] = j = 0; 注意 为了方便数组下标从1开始 前缀是指不包括第i的字符的连续字串集合，后缀是指不包括第1个的后i-1的连续字串集合（必需包括区间端点字符） 回退位数 = 已匹配位数 - next[j]， 用本模板的话就是 j = next[j]这行代码 模式串和原串匹配过程与next数组计算类似 既然我们知道了怎么计算next数组，那么就直接看代码吧 for(int i = 2 , j = 0; i &lt;= n; i ++) { while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j];//回退 if(s[i] == p[j + 1]) j ++; //j == m 代表匹配成功 if(j == m) { j = ne[j];//同样也是回退，因为p[j + 1] == '\\0' != s[]的任何一个字符,所以提前让它回退，避免一些边界问题 //匹配成功后的逻辑 } } 接下来我们做一道模板题好好理解一下这万恶的kmp算法吧 AcWing 831.KMP字符串 题目描述 给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。 模板串P在模式串S中多次作为子串出现。 求出模板串P在模式串S中所有出现的位置的起始下标。 输入格式 第一行输入整数N，表示字符串P的长度。 第二行输入字符串P。 第三行输入整数M，表示字符串S的长度。 第四行输入字符串S。 输出格式 共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。 数据范围 1≤N≤1051≤N≤10^51≤N≤105 1≤M≤1061≤M≤10^61≤M≤106 输入样例： 3 aba 5 ababa 输出样例： 0 2 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 1e5 + 10 , M = 1e6 + 10; int n , m; char p[N] , s[M]; int ne[N]; int main() { scanf(&quot;%d%s%d%s&quot; , &amp;n , p + 1 , &amp;m , s + 1); for(int i = 2 , j = 0; i &lt;= n; i ++) { while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j ++; ne[i] = j; } for(int i = 1 , j = 0; i &lt;= m; i ++) { while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j ++; if(j == n) { j = ne[j]; printf(&quot;%d &quot; , i - n); } } return 0; } 引用 理解kmp的过程挺痛苦的，分享一下我看的那些文章吧 阮一峰的网络日志 字符串匹配的KMP算法 书圈 史上最简(详细)KMP算法讲解，看不懂算我输！ CSDN 漫画：什么是KMP算法？ 阮行止 如何更好地理解和掌握 KMP 算法? ","link":"https://solitudealma.github.io/post/kmp/"},{"title":"二维差分","content":"今天我们来讲一下二维差分 什么是二维差分呢？ 相信了解一维差分的小伙伴都知道，差分和前缀和其实是互逆的。二位前缀和是计算矩阵中的一个点包括其和左上角的所有点的值的和，那么差分的作用就是在时间复杂度是 O(1)O(1)O(1) 的情况下对一个矩阵操作，比如某区域的点都加上一个数。 那么我们应该怎么构建差分数组呢，其实和一维差分差不多，只不过是多了一维。那么有了一维差分的构建经验对于二位差分我们直接用插入函数即可，原理下面会说。 由一维差分我们可以知道， a[i] 是 b[1]...b[i] 的前缀和，如果我们要对区间 [l , r] 中的数都加上一个数c的话只需要让 b[l] += c 并且 b[r + 1] -= c 即可，这样用差分数组构建新数组时，区间 [l , r] 中的数都会在原基础上加上c。 如果我们把这个区间放缩一下，并且让数组元素都为0的这个数组a作为我们的原数组，那么数组a的差分数组b也是全为0，这样我们就构成了差分数组，那么我们真正需要输入到数组中的数就可以利用二位差分的性质进行了，也就是当区间 l = r时，我们让其加上一个需要输入的数，这样既输入了数据，也构成了差分数组。 我们来看一下对任意子矩阵都加上一个数的话，应该怎么利用差分数组。 从图中我们可以很清楚的看到，如果在x1，y1上加一个数c那么它右下角的数都会加上c，那么该怎么办呢，其实这也是容斥定理。我们只需要减去右边多加的部分和下边多加的部分最后再加上重复减去的部分即可 那么代码该怎么写呢，我们来看看模板吧 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 其实挺简单的，我们来做一道模板题熟悉一下吧 AcWing 798.差分矩阵 题目描述 输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。 每个操作都要将选中的子矩阵中的每个元素的值加上c。 请你将进行完所有操作后的矩阵输出。 输入格式 第一行包含整数n,m,q。 接下来n行，每行包含m个整数，表示整数矩阵。 接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。 输出格式 共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。 数据范围 1≤n,m≤1000,1≤n,m≤1000,1≤n,m≤1000, 1≤q≤100000,1≤q≤100000,1≤q≤100000, 1≤x1≤x2≤n,1≤x1≤x2≤n,1≤x1≤x2≤n, 1≤y1≤y2≤m,1≤y1≤y2≤m,1≤y1≤y2≤m, −1000≤c≤1000,−1000≤c≤1000,−1000≤c≤1000, −1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000 输入样例： 3 4 3 1 2 2 1 3 2 2 1 1 1 1 1 1 1 2 2 1 1 3 2 3 2 3 1 3 4 1 输出样例： 2 3 4 1 4 3 4 1 2 2 2 2 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 1010; int n , m , q; int a[N][N] , b[N][N]; void insert(int x1 , int y1 , int x2 , int y2 , int c) { b[x1][y1] += c; b[x1][y2 + 1] -= c; b[x2 + 1][y1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { scanf(&quot;%d%d%d&quot; , &amp;n , &amp;m , &amp;q); for(int i = 1; i &lt;= n; i ++) { for(int j = 1; j &lt;= m; j ++) { scanf(&quot;%d&quot; , &amp;a[i][j]); insert(i , j , i , j , a[i][j]); } } while(q --) { int x1 , y1 , x2 , y2 , c; scanf(&quot;%d%d%d%d%d&quot; , &amp;x1 , &amp;y1 , &amp;x2 , &amp;y2 , &amp;c); insert(x1 , y1 , x2 , y2 , c); } for(int i = 1; i &lt;= n; i ++) { for(int j = 1; j &lt;= m; j ++) { b[i][j] += b[i - 1][j] + b[i][j -1] - b[i - 1][j - 1]; printf(&quot;%d &quot; , b[i][j]); } puts(&quot;&quot;); } return 0; } 引用 引用一些大佬的题解 p_c AcWing 798. 差分矩阵 dongwa_zzuli AcWing 798. 差分矩阵_java vanilla AcWing 798. 差分矩阵 ","link":"https://solitudealma.github.io/post/two_dimensional_difference/"},{"title":"二位前缀和","content":"今天我们来讲一下二位前缀和 什么叫二位前缀和呢？ 给我们一个 n×mn \\times mn×m 的矩阵，矩阵中任意一点的左上角的点的数之和加上这个点的值为该点的二维前缀和 s[i][j]=∑i=1...ij=1...ja[i][j]s[i][j]=\\sum_{i=1...i}^{j=1...j} a[i][j]s[i][j]=∑i=1...ij=1...j​a[i][j]。 那么我们应该怎么用公式求呢？ 首先我们用s数组来表示前缀和，那么 s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i- 1][j - 1] + a[i][j] ，即这一个点的二位前缀和等于它左边的点和上面的点的前缀和之和减去左上角的点的前缀和（即多加的部分）再加上这个点的值就是该点的二维前缀和，其实就是容斥定理。可以结合下图理解。 橙色部分是左边的点的前缀和，红色部分是上面的点的前缀和，绿色的点是重复部分，褐色是当前的点 既然我们求出了每一个点对应的二维前缀和，那么如果需要求子矩阵的二维前缀和呢，该怎么求。 其实也很简单，从定义出发，以（x1，y1）为左上角，（x2，y2）为右上角的子矩阵的前缀和可以看成是（x2，y2）的前缀和减去（x2，y1-1）的前缀和再减去（x1-1，y2）的前缀和最后再加上（x1-1，y1-1）的前缀和即可。用公式表示就是 s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1] 。可以结合下图理解。 红色部分为所求区域，绿色和橙色是多余部分要减去，而灰色部分是多减了要加回来。 到这里相信你也懂得了怎么求矩阵的二维前缀和，那么我们直接上模板吧 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 接着我们来做一道模板题 AcWing 796.子矩阵的和 题目描述 输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。 对于每个询问输出子矩阵中所有数的和。 输入格式 第一行包含三个整数n，m，q。 接下来n行，每行包含m个整数，表示整数矩阵。 接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。 输出格式 共q行，每行输出一个询问的结果。 数据范围 1≤n,m≤1000,1≤n,m≤1000,1≤n,m≤1000, 1≤q≤200000,1≤q≤200000,1≤q≤200000, 1≤x1≤x2≤n,1≤x1≤x2≤n,1≤x1≤x2≤n, 1≤y1≤y2≤m,1≤y1≤y2≤m,1≤y1≤y2≤m, −1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000 输入样例： 3 4 3 1 7 2 4 3 6 2 8 2 1 2 3 1 1 2 2 2 1 3 4 1 3 3 4 输出样例： 17 27 21 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 1010; int n , m , q; int a[N][N] , s[N][N]; int main() { scanf(&quot;%d%d%d&quot; , &amp;n , &amp;m , &amp;q); for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) scanf(&quot;%d&quot; , &amp;a[i][j]) , s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; while(q --) { int x1 , y1 , x2 , y2; scanf(&quot;%d%d%d%d&quot; , &amp;x1 , &amp;y1 , &amp;x2 , &amp;y2); printf(&quot;%d\\n&quot; , s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]); } return 0; } 引用 引用一下大佬的题解 Bug_FreeOωO AcWing 796. 子矩阵的和 zning AcWing 796. 子矩阵的和_Java ","link":"https://solitudealma.github.io/post/two_dimensional_prefix_sum/"},{"title":"一维差分","content":"今天我们来讲一下一维差分 什么是差分呢？ 其实差分和前缀和是逆运算，由定义 b[i]=a[i]-a[i-1] ;可得 a[i]=∑j=1ib[j]a[i] = \\displaystyle\\sum_{j = 1}^i b[j]a[i]=j=1∑i​b[j] ,那么就称b是a的差分数组。差分数组可以将对a数组任意区间的同一操作优化到O(1)O(1)O(1) 那么构造差分数组其实也挺简单的，用第i个元素减去第i-1个元素存入b[i]即可 常见的一维差分操作是令某一段区间的数同时加上一个数，我们利用定义出发很容易就能想到只要在区间起点位置加上一个数就行了，但是这样的话我们构成的新数组就是从起点开始以后的数都加上一个数，因为我们想要的只是一段区间，所以只需要在终点的下一个位置减去这个数即可 我们来看看模板吧 b[l] += c; b[r + 1] -= c; 其实在我们构造一维差分数组是有一个更便捷的方法，就是将一段区间加上一个数这一操作特殊化。 我们将差分数组初始化为0，这时原数组也是0，可以看成b数组是a数组的差分数组，而a数组则是b数组的前缀和数组。那么我们需要对a数组输入数据，就可以看成是对 [i , i] 这个区间加上一个数，那么进行n次操作后我们就可以构造出一个新的差分数组了，因为后续我们需要对一段区间操作，所以利用这一性质我们可以直接合并这一操作，使其利用率更大2333 那么我们直接用模板题试一下吧 AcWing 797.差分 题目描述 输入一个长度为n的整数序列。 接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。 请你输出进行完所有操作后的序列。 输入格式 第一行包含两个整数n和m。 第二行包含n个整数，表示整数序列。 接下来m行，每行包含三个整数l，r，c，表示一个操作。 输出格式 共一行，包含n个整数，表示最终序列。 数据范围 1≤n,m≤100000,1≤n,m≤100000,1≤n,m≤100000, 1≤l≤r≤n,1≤l≤r≤n,1≤l≤r≤n, −1000≤c≤1000,−1000≤c≤1000,−1000≤c≤1000, −1000≤整数序列中元素的值≤1000−1000≤整数序列中元素的值≤1000−1000≤整数序列中元素的值≤1000 输入样例： 6 3 1 2 2 1 2 1 1 3 1 3 5 1 1 6 1 输出样例： 3 4 5 3 4 2 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 100010; int a[N] , b[N]; int n , m; void insert(int l , int r , int c) { b[l] += c; b[r + 1] -= c; } int main() { scanf(&quot;%d%d&quot; , &amp;n , &amp;m); //这里其实也可以不用a数组，用变量也行，但是可能后续需要用到和为了方便理解，所以用到了a数组 for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot; , &amp;a[i]) , insert(i , i , a[i]); while(m --) { int l , r , c; scanf(&quot;%d%d%d&quot; , &amp;l , &amp;r , &amp;c); insert(l , r , c); } // 只需对差分数组求前缀和即可得到操作后的新数组 for(int i = 1; i &lt;= n; i ++) b[i] = b[i - 1] + b[i] , printf(&quot;%d &quot; , b[i]); return 0; } 引用 引用一下我觉得还不错的题解，我解释的可能稍微抽象点 dongwa_zzuli AcWing 797. 差分_java z林深时见鹿 AcWing 797. 差分 【c++详细题解】 自由周某 AcWing 797. 差分 ","link":"https://solitudealma.github.io/post/one_dimensional_difference/"},{"title":"一维前缀和","content":"今天我们来讲讲一维前缀和 首先我们来介绍一下一维前缀和，emmm其实和数列的前n项和差不多，它能在 O(1)O(1)O(1) 的时间复杂度操作数组的任意子区间，比如我们要找出一段区间的和。 我们先预处理出一个前缀和数组，为了方便使用，前缀和数组下标从1开始，数组初始化时我们看作原数组是一个元素全为0的数组，这个在输入数据的同时我们就能对其一边输入一边求前缀和，当然要是不能理解，也是可以分步的 前缀和数组我们用s表示，那么 s[1] 的计算就能看成是 s[0] + a[1] ，即起始下标到当前下标的区间前缀和为 s[i - 1] + a[i] 。那么如果我们要求任意一段区间的前缀和呢？其实也很简单，区间 [l , r] 的前缀和为 a[l] + ... + a[r] 等价于 s[r] - s[l - 1]。 比如我们要求区间3-5的前缀和，那么其实相当于1-5这个区间的前缀和减去1-2这个区间的前缀和 模板其实也很简单 S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] 那么我们直接来做模板题吧 AcWing 795.前缀和 题目描述 输入一个长度为 n 的整数序列。 接下来再输入 m 个询问，每个询问输入一对 l,r。 对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。 输入格式 第一行包含两个整数 n 和 m。 第二行包含 n 个整数，表示整数数列。 接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。 输出格式 共m行，每行输出一个询问的结果。 数据范围 1≤l≤r≤n,1≤l≤r≤n,1≤l≤r≤n, 1≤n,m≤100000,1≤n,m≤100000,1≤n,m≤100000, −1000≤数列中元素的值≤1000−1000≤数列中元素的值≤1000−1000≤数列中元素的值≤1000 输入样例： 5 3 2 1 3 6 4 1 2 1 3 2 4 输出样例： 3 6 10 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 100010; int a[N] , s[N]; int main() { int n , m; scanf(&quot;%d%d&quot; , &amp;n , &amp;m); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot; , &amp;a[i]) , s[i] = s[i - 1] + a[i]; while(m --) { int l , r; scanf(&quot;%d%d&quot; , &amp;l , &amp;r); printf(&quot;%d\\n&quot; ,s[r] - s[l - 1]); } return 0; } 引用 引用一些大佬的题解，他们解释得比较清楚 z林深时见鹿 AcWing 795. 前缀和 【c++详细题解】 Bug_FreeOωO AcWing 795. 前缀和 zning AcWing 795. 前缀和理解_Java ","link":"https://solitudealma.github.io/post/one_dimensional_prefix_sum/"},{"title":"高精度除法的介绍以及模板的分享","content":"今天我们来介绍一下高精度除法 什么是高精度除法呢？ 我们来看看百度百科是怎么介绍高精度除法的，但是并没有搜到相关信息，逛了一圈发现也没人介绍，那我在这里就简单提一下。 一般我们计算高精度除法分为高精度除高精度和高精度除低精度，在这里我们只讲第二种，计算的过程很多时候都是不能整除的，所以我们需要计算商与余数，计算过程也非常简单。 首先我们回想一下在草稿纸上我们是如何计算的，第一步看最高位，最高位除以除数作为商的第一位，对除数求余作为下一步计算的数的一部分，每一次求余过后我们都让余数扩大10倍再加上下一位，如此往复计算即可。 那么我们来看看模板是怎么写的 vector&lt;int&gt; div(vector&lt;int&gt; &amp;A , int b , int &amp;r) { vector&lt;int&gt; C; r = 0; //余数，这里用到了C++的引用，所以返回的时候可以不用返回余数 // 这里正着算，从最高位开始 for(int i = A.size() - 1; i &gt;= 0; i --) { r = r * 10 + A[i]; //计算当前被减数大小 C.push_back(r / b); //计算当前商的对应位数 r %= b; // 更新余数 } reverse(C.begin() , C.end()); //这里将数组翻转过来，因为我们需要去掉前导零 while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 接下来试试模板题吧 AcWing 794.高精度除法 题目描述 给定两个非负整数A，B，请你计算 A / B的商和余数。 输入格式 共两行，第一行包含整数A，第二行包含整数B。 输出格式 共两行，第一行输出所求的商，第二行输出所求余数。 数据范围 1≤A的长度≤100000,1≤A的长度≤100000,1≤A的长度≤100000, 1≤B≤100001≤B≤100001≤B≤10000 B一定不为0B 一定不为0B一定不为0 输入样例： 7 2 输出样例： 3 1 C++代码 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; vector&lt;int&gt; A; string a; int b; vector&lt;int&gt; div(vector&lt;int&gt; &amp;A , int b , int &amp;r) { vector&lt;int&gt; C; r = 0; for(int i = A.size() - 1; i &gt;= 0; i --) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin() , C.end()); while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; // 因为高精度计算往往并不是单单一个，而是两三个一起，所以我们在这里统一存入方式，避免不必要的错误 for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - '0'); int r; auto C = div(A , b, r); for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; cout &lt;&lt; endl &lt;&lt; r; return 0; } 引用 引用一些比较好的题解，比较详细有配图 空_22 AcWing 794. 基础_高精度_高精度除法java_python_c++ zyz. AcWing 794. 高精度除法 Bug_FreeOωO AcWing 794. 高精度除法 ","link":"https://solitudealma.github.io/post/high_precision_division/"},{"title":"高精度乘法的介绍以及模板的分享","content":"今天我们来讲讲高精度乘法 什么是高精度乘法呢？ 我们来看看百度百科什么介绍高精度乘法的，同样是因为存储数据的问题，大整数的乘法必定会有溢出的时候，那么我们应该怎么计算呢 其实乘法的计算也不难，我们这里会介绍高精度与高精度的乘法以及高精度与低精度的乘法，乘法我们用草稿纸演算的时候是按位相乘，就是一个数的每一位乘另一个数的每一位，然后再错位相加（注意不是数列求和的错位相加），还需注意前导零的情况，虽然乘法不会出现前导零，但是因为我们模板的原因，其中一个乘数为零是是会出现一堆零的，所以我们需要去掉多余的零 高精度乘低精度就很简单了，首先我们先把数字倒序存入数组中，然后用数组中的每一位去乘低精度的数对10取余存入结果数组，然后保留进位继续下一次计算，当然你可能会问万一乘出来的数用 unsigned long long 都存不了呢，我只能说这种情况只能用高精度乘高精度的模板了，而且既然题目的意思是高精度乘低精度就不会让你溢出 高精度乘高精度也不难，就是复现了草稿纸上的计算过程 我们直接上模板吧 // 高精度乘低精度 vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A , int b) { vector&lt;int&gt; C; int t = 0; // 循环的判断是如果A算完了，但是最高位要进位需要再算一次，当然分离出去也行 for(int i = 0; i &lt; A.size() || t; i ++) { if(i &lt; A.size()) t += A[i] * b; //if的判断配合循环判断 C.push_back(t % 10); //模10就是我们要的结果 t /= 10; // 保留进位 } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); //如果乘数为零则去前导零 return C; } // 高精度乘高精度 vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C(A.size() + B.size() , 0); //初始化，以免里面的数不是零，用于但是存相加的对应位结果 int t = 0; // 计算对应位相加后的结果 for(int i = 0; i &lt; A.size(); i ++) for(int j = 0; j &lt; B.size(); j ++) C[i + j] += A[i] * B[j]; // 计算对应位真正的结果 for(int i = 0; i &lt; C.size(); i ++) { t += C[i]; C[i] = t % 10; t /= 10; } // 去前导零，以免出现这种情况 while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 接下来我们来一道模板题 AcWing 793.高精度乘法 题目描述 给定两个正整数A和B，请你计算A * B的值。 输入格式 共两行，第一行包含整数A，第二行包含整数B。 输出格式 共一行，包含A * B的值。 数据范围 1≤A的长度≤100000,1≤A的长度≤100000,1≤A的长度≤100000, 0≤B≤100000≤B≤100000≤B≤10000 输入样例： 2 3 输出样例： 6 C++代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A; string a; int b; vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A , int b) { vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; A.size() || t; i ++) { if(i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); auto C = mul(A , b); for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; return 0; } 引用 引用一些大佬的题解，其中有高精度乘高精度的模板，思路很不错orz，也有java的实现以及数组的实现 Anish AcWing 793. 高精度乘法 A x b 和 A x B 的模版 师大专升本16级学长 AcWing 793. 高精度乘法（C语言新手版） 小呆呆 AcWing 793. 高精度乘法 ","link":"https://solitudealma.github.io/post/high_precision_multiplication/"},{"title":"题解：AcWing 792.高精度减法","content":"题目链接 AcWing 792.高精度减法 引用 数组实现的看一看下面引用的题解；也有Java的实现方法，虽然Java有大数类；对压位感兴趣的小伙伴也可以看看 师大专升本16级学长 AcWing 792. 高精度减法（C语言新手版） jasonlin AcWing 792. 高精度减法 小呆呆 AcWing 792. 高精度减法 Accepting AcWing 792. 高精度减法(压位) 题目描述 给定两个正整数，计算它们的差，计算结果可能为负数。 样例 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的差。 数据范围 1≤整数长度≤1051≤整数长度≤1051≤整数长度≤105 输入样例： 32 11 输出样例： 21 算法 (高精度减法) O(n)O(n)O(n) 高精度减法和加法区别不大，存储的时候我们也是倒序存入数组中，因为我们都知道，减法的过程中是会向前借位的，同样的，如果最高位是1，借位后为0，那么我们就不能够直接输出数组元素，必须先去掉前导零；还有就是因为减法是会产生负数，所以在计算之前我们应该先比较两个数的大小，通过数组长度以及从最高位开始对应位的大小；还有就是借位了，有一个很巧妙的计算借位相减后的数字， (t + 10) % 10 怎么理解呢， t存的是对应位相减的结果无论结果是正数还是负数，计算后都会得到正确的结果，然后根据t是否大于零来判断是否借位了。 负数记得输出负号哦~~~ 时间复杂度 O(n)O(n)O(n) 根据数的长度决定循环的次数，所以时间复杂度也是线性的 参考文献 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; bool cmp(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() != B.size()) return A.size() &gt; B.size(); for(int i = A.size() - 1; i &gt;= 0; i --) if(A[i] != B[i]) return A[i] &gt; B[i]; return true; } vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; A.size(); i ++) { t = A[i] - t; if(i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if(t &lt; 0) t = 1; else t = 0; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - '0'); vector&lt;int&gt; C; if(cmp(A , B)) C = sub(A , B); else C = sub(B , A) , cout &lt;&lt; '-'; for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; return 0; } ","link":"https://solitudealma.github.io/post/AcWing792/"},{"title":"高精度减法的介绍以及模板的分享","content":"今天我们来讲一下高精度减法 首先什么是高精度减法呢？☹️☹️☹️ 我们来看一下百度是怎么介绍高精度减法的,没想到百度居然偷懒，那我也顺带放上高精度加法的介绍吧。 也可以看看我之前对于高精度加法的介绍 高精度减法和加法区别不大，存储的时候我们也是倒序存入数组中，因为我们都知道，减法的过程中是会向前借位的，同样的，如果最高位是1，借位后为0，那么我们就不能够直接输出数组元素，必须先去掉前导零；还有就是因为减法是会产生负数，所以在计算之前我们应该先比较两个数的大小，通过数组长度以及从最高位开始对应位的大小；还有就是借位了，有一个很巧妙的计算借位相减后的数字， (t + 10) % 10 怎么理解呢， t存的是对应位相减的结果无论结果是正数还是负数，计算后都会得到正确的结果，然后根据t是否大于零来判断是否借位了。 负数记得输出负号哦~~~ 接下来我们来看看模板👇👇👇 bool cmp(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() != B.size()) return A.size() &gt; B.size();// 如果位数不相等，返回A &gt; B 的结果 // 遍历A与B的每一位，此时位数相同，用A或者B的size都行，只要有一位不同，就返回A[i] &gt; B[i] 的结果 for(int i = A.size() -1; i &gt;= 0; i --) if(A[i] != B[i]) return A[i] &gt; B[i]; return true; } vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C; // 存放结果 int t = 0; // 记录是否借位 for(int i = 0; i &lt; A.size(); i ++) { t = A[i] - t; //减去借位 if(i &lt; B.size()) t -= B[i]; //未减完就继续减 C.push_back((t + 10) % 10); //放入对应位结果 if(t &lt; 0) t = 1; //判断是否借位，小于零则借位 else t = 0; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); //去前导零 return C; } cmp函数是比较减数与被减数的大小，sub函数就是减法的具体内容了 模板内容就这么多，很好理解的，输出的时候记得倒序输出 那么我们来一道模板题练练手👏👏👏 AcWing 792. 高精度减法 题目描述 给定两个正整数，计算它们的差，计算结果可能为负数。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的差。 数据范围 1≤整数长度≤1051≤整数长度≤1051≤整数长度≤105 输入样例： 32 11 输出样例： 21 C++代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; bool cmp(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() != B.size()) return A.size() &gt; B.size(); for(int i = A.size() - 1; i &gt;= 0; i --) if(A[i] != B[i]) return A[i] &gt; B[i]; return true; } vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; A.size(); i ++) { t = A[i] - t; if(i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if(t &lt; 0) t = 1; else t = 0; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - '0'); vector&lt;int&gt; C; if(cmp(A , B)) C = sub(A , B); else C = sub(B , A) , cout &lt;&lt; '-' ; for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; return 0; } 引用 数组实现的看一看下面引用的题解；也有Java的实现方法，虽然Java有大数类；对压位感兴趣的小伙伴也可以看看🤺🤺🤺 师大专升本16级学长 AcWing 792. 高精度减法（C语言新手版） jasonlin AcWing 792. 高精度减法 小呆呆 AcWing 792. 高精度减法 Accepting AcWing 792. 高精度减法(压位) ","link":"https://solitudealma.github.io/post/high_precision_subtraction/"},{"title":"题解：AcWing 791.高精度加法","content":"题目链接 AcWing 791. 高精度加法 引用 引用一下大佬的题解，其中有用数组实现的，也有Java的实现，也有string的实现以及压位，大佬们也太厉害了，orz~~~ lyclyc_NSP AcWing 791. 高精度加法C++数组实现 小呆呆 AcWing 791. 高精度加法 二月 AcWing 791. 高精度加法（使用string，30行） c++ 就是个渣渣 AcWing 791. 高精度加法 题目描述 给定两个正整数，计算它们的和。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的和。 数据范围 1≤整数长度≤1000001≤整数长度≤1000001≤整数长度≤100000 输入样例： 12 23 输出样例： 35 算法 (高精度加法) O(n)O(n)O(n) 高精度加法其实不难，首先我们肯定是存不下这个数的，所以可以用字符数组或者string读取，然后倒序存入vector中，加法计算过程只要注意进位即可，还有最高位可能要进位，所以需要判断一下 时间复杂度 O(n)O(n)O(n) 根据数的长度决定循环的次数，所以时间复杂度也是线性的 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; vector&lt;int&gt; add(vector&lt;int&gt; &amp;A ,vector&lt;int&gt; &amp;B) { if(A.size() &lt; B.size()) return add(B , A); vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; (int)A.size(); ++ i) { t += A[i]; if(i &lt; (int)B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; // a[i] - '0' 是通过ACII码的差值计算该字符转为数字时的大小 for(int i = a.size() - 1; i &gt;= 0; -- i) A.push_back(a[i] - '0'); for(int j = b.size() - 1; j &gt;= 0; -- j) B.push_back(b[j] - '0'); // auto是C++11的新特性，编译器会自动识别变量的类型，相当方便，如果不可以用，那就用标识符定义吧 auto C = add(A , B); for(int k = C.size() - 1; k &gt;= 0; -- k) cout &lt;&lt; C[k]; return 0; } ","link":"https://solitudealma.github.io/post/AcWing791/"},{"title":"高精度加法的介绍以及模板的分享","content":"简单介绍一下高精度加法（高精度加高精度或低精度都可以用） 什么是高精度加法呢？🤣🤣🤣 简单点说就是当我们计算的时候，如果数据过大，那么我们使用的数据类型可能存不下，比如 int 的范围是 $-2^{31} $ ~ 231−12^{31}-1231−1（中间有个0），那么你存的数的位数不能超过9位数，但是很多时候数据都会很大，有些人会说，那我用 long 也行啊，我只能说有时候你用 unsigned long long 都不够，可见数据位数之长。 详情可以看看这个高精度算法😘😘😘 这里我们只解决高精度整数加法，一般也不考浮点数吧，emmm😜😜😜 那这种数据我们应该怎么处理呢？很简单。既然存不下，那我们就用字符串（字符数组也行，C++特有的数据类型string，其实也等价于字符数组，只不过更方便使用）读入，然后将其每一位存入数组中即可，只要我们的数组够大，就能完成我们的计算（不TLE的前提，既然题目明确要用这种方法就不会让你超时）。 但是对于加法我们都知道的一点，也是最重要的一点。那就是十进制数是满十进一，因为我们是用数组去存数的每一位，所以在计算的时候我们应该倒序存数的每一位，即数组的第一位存的不是最高位而是最低位，这样在我们进位的时候会更加方便（最高位可能也要进位，而这时数组第0位已经有数了，再放就越界了，得把数组中的数往后移，这样就会特别麻烦）。 那么我们先看看模板是怎样的👇👇👇 不知道vector的小伙伴可以看看这个vector介绍 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 vector&lt;int&gt; add(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() &lt; B.size()) return add(B , A);//如果被加数长度小于加数那么就调整顺序，如果不加这一句就需要变动一下for循环，i多判断一次是否小于B的大小（即算完最长的数的位数才停），然后 t += A[i] 用 if(i &lt; A.size())包裹 vector&lt;int&gt; C;// 定义一个答案 int t = 0; // 存储进位 for(int i = 0; i &lt; A.size(); ++ i) { t += A[i]; if(i &lt; B.size()) t += B[i]; //如果B还没加完就继续 C.push_back(t % 10); // mod 10 的结果就是对应位的结果 push_back 是往数组后面插入一个数 t /= 10; //整除10表示进位是多少 } if(t) C.push_back(c); // t为0，表示最高位无进位，大于0表示有进位。也可以写入for循环，自行思考 return C; } 这个模板并不难理解，输出答案的时候记得倒序输出就是了。 我们直接上模板题👇👇👇 AcWing 791. 高精度加法 题目描述 给定两个正整数，计算它们的和。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的和。 数据范围 1≤整数长度≤1000001≤整数长度≤1000001≤整数长度≤100000 输入样例： 12 23 输出样例： 35 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; vector&lt;int&gt; add(vector&lt;int&gt; &amp;A ,vector&lt;int&gt; &amp;B) { if(A.size() &lt; B.size()) return add(B , A); vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; (int)A.size(); ++ i) { t += A[i]; if(i &lt; (int)B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; // a[i] - '0' 是通过ACII码的差值计算该字符转为数字时的大小 for(int i = a.size() - 1; i &gt;= 0; -- i) A.push_back(a[i] - '0'); for(int j = b.size() - 1; j &gt;= 0; -- j) B.push_back(b[j] - '0'); // auto是C++11的新特性，编译器会自动识别变量的类型，相当方便，如果不可以用，那就用标识符定义吧 auto C = add(A , B); for(int k = C.size() - 1; k &gt;= 0; -- k) cout &lt;&lt; C[k]; return 0; } 引用 有大佬用数组写了一遍，可以参考，记得去前导零，因为开数组的时候都是比数据范围大，（emmm，其实也可以不用，不过写成函数的话可以搞个计数器，记录位数，然后输出2333，灵活运用吧），orz Java的小伙伴也可以学一下，貌似有些题目不能用Big Integer，毕竟算法这个东西学到一点是一点，不能因为语言特性而不去学 还有一点就是用数组貌似比STL快了一倍，不过这时差可以忽略不计，但是比如链表的操作这些用数组作为静态链表去模拟的话速度会快很多，而且写法也简单，特别是数据很大的时候，用数组往往是很好的选择，当然这也是后话了 对于压位感兴趣的小伙伴也可以试试，引用的题解中有，但是一般应该用不上 lyclyc_NSP AcWing 791. 高精度加法C++数组实现 小呆呆 AcWing 791. 高精度加法 二月 AcWing 791. 高精度加法（使用string，30行） c++ 就是个渣渣 AcWing 791. 高精度加法 ","link":"https://solitudealma.github.io/post/high_precision_addition/"},{"title":"题解：AcWing 790.数的三次方根","content":"题目链接 AcWing 790.数的三次方根 引用 引用一下还不错的题解 第一WA者金银花 AcWing 790. 数的三次方根 zning AcWing 790. 浮点数二分法_Java modeming AcWing 790. 数的三次方根（牛顿迭代法） 题目描述 给定一个浮点数n，求它的三次方根。 样例 输入格式 共一行，包含一个浮点数n。 输出格式 共一行，包含一个浮点数，表示问题的解。 注意，结果保留6位小数。 数据范围 −10000≤n≤10000−10000≤n≤10000−10000≤n≤10000 输入样例： 1000.001000.001000.00 输出样例： 10.00000010.00000010.000000 算法 (浮点数二分) O(n)O(n)O(n) 关于浮点数二分就没什么好说的了，因为精度问题，像三次方根平方根这些都只能找到大概的范围，所以我们只要不断缩小范围即可，设定一个精度eps，如果题目说精确到6位，那我们设置的精度就为 1e−81e-81e−8。 有一个需要注意的点是，求平方根时，如果输入的数是 &lt; 1 &amp;&amp; &gt;0，那么计算的时候就要注意了，比如0.1的平方根，那么答案肯定是在0.1到1之间，所以应该特殊处理区间更新方式 时间复杂度 O(n)O(n)O(n) 最多查找 n/2n/2n/2 次，所以时间复杂度是线性的 C++ 代码 #include &lt;cstdio&gt; using namespace std; double n; int main() { scanf(&quot;%lf&quot; , &amp;n); double l = -1000 , r = 1000 , eps = 1e-8; while(r - l &gt; eps) { double mid = (l + r) / 2; if(mid * mid * mid &gt;= n) r = mid; else l = mid; } printf(&quot;%.6lf&quot; , l); return 0; } ","link":"https://solitudealma.github.io/post/AcWing790/"},{"title":"2021.02.19 [日记]","content":"又是摸鱼的一天，一直睡到10点多才起床。起床后想到了可以给GitHub Pages改个自定义域名，u1s1，仓库名访问真的又臭又长，说干就干，百度了一下怎么操作。哦，越来加上A记录和CNAME记录就行啦，那简单，ping了一下原来的域名，搞到了ip，然后在仓库设置里填子域名即可，接着一通操作，ojbk。一访问，？？？，样式去哪了？出你妈大事。并且Github告诉我，我的DNS还未生效 Domain's DNS record could not be retrieved. 。然后我想了一下，可能是我配置的同时把DNS服务器从阿里云的改成了腾讯云。所以提示了这个？然后我又重新填了一边，发现，诶？可以正常访问了。晚上看了一下大佬的回答说是因为Github用了cdn，所以依然会有那个提示，具体原因不太清楚，反正能用就行2333。 昨晚帮一个初中生解决了个小问题，然后突然提到他朋友6年级就搭建了一个OJ平台和博客，初中搞信息奥赛的都是大佬，真的是后生可畏啊...当然别人厉害之余我们也应该多去学习，而不是停滞不前，毕竟比你牛的人都在努力，你又有什么理由不努力呢。当他说出OJ平台的时候我下意识的以为是评测系统，也就是测试数据的部分，毕竟刷过题的小伙伴都知道测试数据的部分不好搞，得限制时间和空间，测试结果不能返回过慢，多人同时测试时不能等待时间过长等等一系列优化问题。突然有一种想自己搞一个OJ平台的冲动，然后昨晚睡前简单的百度了一下，发现一个完整的OJ平台包括题库，比赛&amp;作业，排名等等，看来挺有搞头的，而且完成之后对于前后端开发都会有很大的提升。不过很大程度上做不完，哈哈哈。开学再看吧，溜了溜了。 ","link":"https://solitudealma.github.io/post/20200219/"},{"title":"题解：AcWing 789.数的范围","content":"题目链接 AcWing 789.数的范围 引用 引用一下我觉得还不错的题解，%%% 秦淮岸灯火阑珊 AcWing 789. 数的范围 Bug_FreeOωO AcWing 789. 数的范围 醉生梦死 AcWing 789. 二分算法的证明和边界分析 AdaMeta AcWing 789. 二分模板笔记 题目描述 给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。 对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。 如果数组中不存在该元素，则返回“-1 -1”。 样例 输入格式 第一行包含整数n和q，表示数组长度和询问个数。 第二行包含n个整数（均在1~10000范围内），表示完整数组。 接下来q行，每行包含一个整数k，表示一个询问元素。 输出格式 共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回“-1 -1”。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 1≤q≤100001≤q≤100001≤q≤10000 1≤k≤100001≤k≤100001≤k≤10000 输入样例： 6 3 1 2 2 3 3 4 3 4 5 输出样例： 3 4 5 5 -1 -1 算法 (二分) O(n)O(n)O(n) 相信大家在没有学习算法的时候多多少少都对二分法有一定的了解，二分法在查找的过程通过和区间中间值进行比较从而确定所找的值是中间值还是在左区间或是右区间。 一个题目，如果一个区间具有单调性质，那么一定可以二分，但是如果说这道题目没有单调性质，而是具有某种区间性质的话，我们同样可以使用二分。 ——yxc总 常见的可以二分的题 在区间中找一个数 本题中位置的最值即大于等于或小于等于某个值 某个东西是否存在 仔细分析题目意思2333 二分算法在选择区间时，选择的区间一定是存在答案的 做这道题可以直接上模板，但是模板有一些需要注意的地方 比如我们在 1223451 2 2 3 4 5122345 中找到2在序列中第一次出现的位置和最后一次出现的位置，首先我们先确定中间下标，将区间划分为左右两个区间，然后根据check函数判断来更新区间，因为我们需要寻找第一次出现的位置，所以check我们可以这么写 if(a[mid] &gt;= target) r = mid; ，那么最后一次出现就应该是 if(a[mid] &lt;= target) l = mid; 。这里要注意一点，为什么会有两个模板呢，因为区间的更新有两种情况，第一种就是左区间包含mid，第二种就是左区间不包含mid，而我们计算mid的时候是 l + r &gt;&gt; 1 ，当 l+1=rl + 1 = rl+1=r 并且是第二种划分情况时，如果依然是 l + r &gt;&gt; 1 的话，会造成死循环，也就是TLE，区间会一直停留在原地，所以左区间不包含mid时应该向上取整。 当然这两个模板无论哪一个都可以求你要找的那个数，所以如果只出现一次的话哪个都行，也就不存在无限循环的情况！！！ 贴上模板 bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 作者：yxc 链接：https://www.acwing.com/blog/content/277/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这里再说一下满足某种性质的区间，比如上面找2出现的位置，那么划分区间时，我们根据选的区间是否满足 &gt;=target&gt;= target&gt;=target 或者 &lt;=target&lt;= target&lt;=target 这一性质来判断我们找的数是不是在这个区间 时间复杂度 O(n)O(n)O(n) 最多查找 n/2n/2n/2 次，所以时间复杂度是线性的 C++ 代码 #include &lt;cstdio&gt; using namespace std; const int N = 1e5 + 10; int n , q; int a[N]; int main() { scanf(&quot;%d%d&quot; , &amp;n , &amp;q); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); while(q --) { int k; scanf(&quot;%d&quot; , &amp;k); int l = 0 , r = n - 1; while(l &lt; r) { int mid = l + r &gt;&gt; 1; if(a[mid] &gt;= k) r = mid; else l = mid + 1; } if(a[l] != k) printf(&quot;-1 -1\\n&quot;); else { printf(&quot;%d &quot; , l); l = 0 , r = n - 1;//l可更新可不更新 while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if(a[mid] &lt;= k) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot; , l); } } return 0; } ","link":"https://solitudealma.github.io/post/AcWing789/"},{"title":"题解：AcWing 788.逆序对的数量","content":"题目链接 AcWing 788.逆序对的数量 引用 看了大佬的题解后对于归并又有了更深的理解，在这里引用一下dongwa_zzuli大佬的题解AcWing 788. 逆序对的数量，感兴趣的小伙伴可以看看 题目描述 给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。 逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。 样例 输入格式 第一行包含整数n，表示数列的长度。 第二行包含 n 个整数，表示整个数列。 输出格式 输出一个整数，表示逆序对的个数。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 6 2 3 4 5 6 1 输出样例： 5 算法 (归并排序) O(nlogn)O(nlogn)O(nlogn) 做这道题的话因为序列是不能被打乱的，而归并排序开始排序之前，序列还是原来的样子。根据这道题的性质我们可以发现，一共有三种情况，也就是这两个数的位置。 刚好在左区间 刚好在右区间 大的数在左区间，小的数在右区间 前两个情况很好求，在我们处理左右区间时就可以求出来，那么第三种呢。其实也不难，根据归并的性质可以知道在归并到最后一个区间的时候左右两个子区间是有序的，那么我们归并的时候可以判断一下，如果左指针所指的数大于右指针所指的数，那么左指针后的所有数都将大于它，那么这个数构成的逆序对就是 mid - i + 1 ，那么只需将所有这种情况加起来，再加上前两种情况就行了。前两种情况其实在合并为将它们分开时的那个区间时就已经计算完了，只需把 merge_sort(q , l , mid) 和 merge_sort(q , mid + 1 , r) 这两个结果加起来就行了，虽然看上去有点绕，但是如果你知道归并的过程的话，其实就能明白了，还是不太清楚的话建议手动模拟一下，也可以看看我画的图 其实这里还有一个很小的细节，因为我们需要存储逆序对的数量，当序列是倒序的时候逆序列是最多的，即对 n−1+n−2+n−3...+1n-1 + n-2 + n -3 ... + 1n−1+n−2+n−3...+1 ==&gt;&gt; ∑i=1nn\\sum_{i=1}^nn∑i=1n​n 也就是 n(n−1)2\\frac{n(n - 1)}{2}2n(n−1)​ ，当n为 1e51e51e5 时，逆序对的数量为 5×109−5×1045\\times10^9-5\\times10^45×109−5×104，已经超出int的范围了所以我们应该用long或者long long存 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 一共划分 lognlognlogn 次区间，每一层都是n次，所以时间复杂度是 O(nlogn)O(nlogn)O(nlogn) C++ 代码 #include &lt;cstdio&gt; using namespace std; typedef long long LL; const int N = 1e5 + 10; int n; int a[N]; LL merge_sort(int q[] , int l , int r) { if(l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_sort(q , l , mid) + merge_sort(q , mid + 1 , r); int i = l , j = mid + 1 , k = 0 , temp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(q[i] &lt;= q[j]) temp[k ++] = q[i ++]; else { res += mid - i + 1; temp[k ++] = q[j ++]; } } while(i &lt;= mid) temp[k ++] = q[i ++]; while(j &lt;= r) temp[k ++] = q[j ++]; for(int i = l , j = 0; i &lt;= r; ++ i , ++ j) q[i] = temp[j]; return res; } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); LL res = merge_sort(a , 0 , n - 1); printf(&quot;%lld&quot; , res); return 0; } ","link":"https://solitudealma.github.io/post/AcWing788/"},{"title":"题解：AcWing 786.第K个数","content":"题目链接 AcWing 786.第k个数 引用 星丶空大佬的题解，很不错的思路，奇怪的思路+1 并没有 写一个和yxc大佬不同但差不多思想的方法，代码更简单 题目描述 给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。 样例 输入格式 第一行包含两个整数 n 和 k。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整数数列。 输出格式 输出一个整数，表示数列的第k小数。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000, 1≤k≤n1≤k≤n1≤k≤n 输入样例： 5 3 2 4 1 5 3 输出样例： 3 算法 (快速选择) O(n)O(n)O(n) 从快排的性质可以知道，每次划分区间的时候j左边的数都是小于等于x的，右边的都是大于等于x的。所以如果左区间的长度大于等于k，那么第k个数必定在左区间，所以我们只需递归左区间，反过来，如果k大于左区间长度，那么第k个数在右区间，那么相对于右区间，第k个数在右区间中变为第（k - 左区间的长度）个数，然后递归右区间即可。 时间复杂度 O(n)O(n)O(n) emmm，问就是不知道怎么算的，不过肯定比 O(nlogn)O(nlogn)O(nlogn) 小，等我看了y总的时空复杂度分析再来补吧，哈哈哈 C++ 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int n , k; int a[N]; int quick_sort(int q[] , int l , int r , int k) { if(l &gt;= r) return q[l]; int i = l - 1 , j = r + 1 , x = q[l + r &gt;&gt; 1]; while(i &lt; j) { do ++ i; while(q[i] &lt; x); do -- j; while(q[j] &gt; x); if(i &lt; j) swap(q[i] , q[j]); } int len = j - l + 1; if(len &gt;= k) return quick_sort(q , l , j , k); else return quick_sort(q , j + 1 , r , k - len); } int main() { scanf(&quot;%d%d&quot; , &amp;n , &amp;k); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); int res = quick_sort(a , 0 , n - 1 , k); printf(&quot;%d&quot; , res); return 0; } ","link":"https://solitudealma.github.io/post/AcWing786/"},{"title":"对归并排序的一些理解","content":"今天我们来介绍一下归并排序 那么什么是归并排序呢？🤔🤔🤔 百度百科是这么说的:归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 也可以看看动态图😮😮😮 归并排序也和快速排序一样利用分治法来解决问题，同样它也采用了双指针算法（排序的时候），首先将一个有序或者无序的序列按中间索引（下标）分成两个部分，然后再将这两个部分继续分，直到区间长度为1。一个长度为n的区间一共需要分 log2nlog_2nlog2​n 次才能将区间分完。分完区间后就是对区间进行排序，然后合并区间即可。 因为一共需要分 log2nlog_2nlog2​n 次区间，所以归并排序的时间复杂度为 O(nlogn)O(nlogn)O(nlogn) 我们先来看看归并排序的模板👇👇👇 void merge_sort(int q[] , int l , int r) { if(l &gt;= r) return;//区间只有一个数的时候停止递归 int mid = l + r &gt;&gt; 1;//划分区间 merge_sort(q , l , mid) , merge_sort(q , mid + 1 , r);//递归划分左右区间 int i = l , j = mid + 1 , k = 0 , temp[r - l + 1];//i为左区间的指针，j为右区间的指针，k为排序的第几个数，temp数组用于合并区间时临时存储,temp也可以直接开一个和q一样大的全局变量，看个人喜好 //两个区间的数进行比较，小的或者相等的数将左区间的数放入temp，否则右区间放入 while(i &lt;= mid &amp;&amp; j &lt;= r) { if(q[i] &lt;= q[j]) temp[k ++] = q[i ++]; else temp[k ++] = q[j ++]; } // 因为存在还没比较完就有一个区间已经没有数了，所以将剩余的数全部放在temp后，一下while只有一个会执行 while(i &lt;= mid) temp[k ++] = q[i ++]; while(j &lt;= r) temp[k ++] = q[j ++]; for(int i = l , j = 0; i &lt;= r; ++ i , ++ j) q[i] = temp[j];//将temp数组更新到q数组中，q即为排序后的数组 } 归并排序的三个步骤 确定分界点 mid = l + r &gt;&gt; 1; 递归排序左右区间 归并区间❤️❤️❤️ 首先将区间一直划分，直到区间长度为1，接着排序左右区间，最后合并区间。 合并区间之前，区间一定是有序的 从左区间开始排序，此时区间中只有一个3，递归停止（只有一个元素不需要排序），排完后轮到右区间，此时区间中也是只有一个数，不需要排序，递归停止。跳回到上一层递归，然后排序3和1，因为本层递归将区间用mid划分了，也就是意义上的左右区间，形式上还是在同一个数组中，因为 q[i] = 3 是大于 q[j] = 1 的，所以将 q[j] 放入temp数组中，要注意这里的k++，++的位置意味着如果它在一个表达式中的话运算顺序是不一样的，除非它单独为一条语句，那它的位置在哪都一样，如果不能理解的话，单独拎出来自增也是可以的。然后此时 i &gt; mid ，所以while循环停止，接着把未比较完的数放进temp中，这样就合并完第一个区间了，然后更新q数组的前两个位置，如此往复就能把数组排序完了。 老规矩，自己手动模拟的话能更快的理解。 一些细节 k++和++k在单独的一个语句中并没有什么区别，k都会自增。但是如果在一个表达式中的话就不一样了，比如temp[k ++] = q[i ++],在这里是先用k和i的值，然后k和i再加1。我是这么记的，谁在前面谁先执行，即k++是先赋值后加1，++k是先加1后赋值 emmm,好像没有了，有的时候再加上吧 这个算法的难点在于合并区间，必定会有一个区间先比较完，然后得把剩余的所有数全部放入temp数组中，模板中的方法就很不错 又到了呈上例题的时候🤣🤣🤣 AcWing 787. 归并排序 题目描述 给定你一个长度为n的整数数列。 请你使用归并排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式 输入共两行，第一行包含整数 n。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。 输出格式 输出共一行，包含 n 个整数，表示排好序的数列。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 555 312453 1 2 4 531245 输出样例： 123451 2 3 4 512345 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 100010; int n; int a[N]; void merge_sort(int q[] , int l , int r) { if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q , l , mid) , merge_sort(q, mid + 1 , r); int i = l , j = mid + 1 , k = 0 , temp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(q[i] &lt;= q[j]) temp[k ++] = q[i ++]; else temp[k ++] = q[j ++]; } while(i &lt;= mid) temp[k ++] = q[i ++]; while(j &lt;= r) temp[k ++] = q[j ++]; for(int i = l , j = 0; i &lt;= r; ++ i , ++ j) q[i] = temp[j]; } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); merge_sort(a , 0 , n - 1); for(int i = 0; i &lt; n; ++ i) printf(&quot;%d &quot; , a[i]); return 0; } 以上就是我对归并算法的一些理解，如有错误的地方请大佬们指出。🤺🤺🤺 ","link":"https://solitudealma.github.io/post/merge_sort/"},{"title":"快速排序的介绍以及算法的模板分享","content":"今天我们来讲一下快速排序 更好的阅读体验 那么什么是快排呢？🤔🤔🤔 百度百科是这么介绍的：快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 也可以看看动态图😮😮😮 它的主要思想是分治法，就是把一个问题分成相互独立的几个规模较小的子问题，然后逐一去解决，最终将得到“母问题的答案”。链接 ==&gt;&gt;分治法 今天我们将采用双指针算法去理解快速排序这一过程，对于双指针算法不太理解的小伙伴可以看看这个介绍 ==&gt;&gt; 算法 | 双指针套路总结 双指针算法基本原理和实践 因为我们是用数组去排序的，所以你只需要知道双指针代表着两个在改变的下标就行了（下标访问本质上也是指针）。 快排的平均时间复杂度为O(nlog2n)O(nlog_2n)O(nlog2​n)，最糟糕的时候是O(n2)O(n^2)O(n2)。 首先我们先给出我们的快排模板👇👇👇 void quick_sort(int q[] , int l , int r) { if(l &gt;= r) return; //表示此区间只有一个数或者没有数 int i = l - 0 , j = r + 1 , x = q[l + r &gt;&gt; 1]; //i为左指针，j为右指针 x为每一次分割区间时选定的比较数 &gt;&gt; 这个是右移运算符，是位运算的一种，将一个整数右移一位表示除以2 while(i &lt; j) { do ++ i; while(q[i] &lt; x); //左指针寻找小于x的数 do -- j; while(q[j] &gt; x); //右指针寻找大于x的数 if(i &lt; j) swap(q[i] &lt; q[j]); //swap函数存在于C++的algorithm头文件中，相当于自己手写的交换变量函数，因为指针停下来的时候可能是穿过，重合这两种情况其中一种，如果未相遇我们就交换指针所指的数，然后直到l&gt;=r循环结束 } //每一次递归之后i、j的相对位置只有两种情况，i==j或者i==j+1 quick_sort(q , l , j) , quick_sort(q , j + 1 , r);//递归处理左右区间，先左，再右（注意划分区间用的是i还是j） } 好了，以上就是我们要用到的快排模板了，一个好的模板能让你快速记忆一个算法，同时它也已经帮我们解决了烦人的边界问题，只需要好好理解记忆即可 快排的三个步骤 确定分界点 q[l] , q[l + r &gt;&gt; 1] , q[r] , 随机 调整区间 保证左边小于等于x，右边大于等于x，x在哪一边都可以💗💗💗 递归处理左右两段 这个模板其实不难理解，函数传入一个含有n个元素的有序或者无序的序列，我们用分治法的思想，首先先确定分界点，因为选取的是l + r &gt;&gt; 1也就是中间元素；而后寻找满足条件的数，直到 l&gt;=rl &gt;= rl&gt;=r ,接着调整区间，将其分为&gt;=x&gt;=x&gt;=x和&lt;=x&lt;=x&lt;=x的两个区间（用j划分，j的左边一定小于等于x，j的右边一定大于等于x）；最后再递归处理左右区间。 如果一个区间只有一个元素，而这个区间又满足小于等于x或者大于等于x这一条件，那么整个合并的区间都是有序的。 一共需要分log2nlog_2nlog2​n次,在第log2nlog_2nlog2​n次时每一个元素都在一个区间里，在那个区间中它是有序的。也是至此递归不再继续，因为区间中只有一个元素（ l&gt;=rl &gt;= rl&gt;=r ），还是不明白的小伙伴可以动手模拟一下，画一下图会清晰很多 一些细节 1.i , j 指针每次都在区间之外，这是因为我们用了do-while循环，每一次指针都是先+1/-1，再判断，这样可以避免死循环等一些迷之操作（其实一般来说都是先判断再操作，这样的话避免回退操作，这里用do-while循环是为了方便理解） 2.选取元素的作为比较的值时尽量不要选取左右端点，因为当序列有序时，时间复杂度会退化为O(n2)O(n^2)O(n2) 3.如果选取右端点，则递归处理的代码为quick_sort(q , l , i - 1) , quick_sort(q , i , r);如果选的是左端点，则为quick_sort(q , l , j) , quick_sort(q , j + 1 , r);；如果选取中间点，两种都可以哦，但是中点选取变为 q[l + r + 1 &gt;&gt; 1] 4.一切有关边界问题的算法都建议背模板，因为这是经过n位大佬试验过的，只需要记就行了 5.如果用的时候无论如何都想不起快排的模板的话，还有一个暴力的方式。1.首先我们先创建a，b两个数组；2.遍历数组q，小于等于x的数放入a中，其他的放入b中；3.将a，b分别排序后，先将a中的元素放入q，再将b中的元素放入q即可 6.最后最后，还是用j做分界点和q[l + r &gt;&gt; 1]做目标值为好，这样能规避所有边界问题 这个算法难点在于调整区间,以j来划分区间的话，在j左边的数都小于等于x，在右边的都大于等于x，其他同理，应该注意你用的是i还是j来划分区间 附上一个简单的快速排序图解 现在我们来写一道模板题 AcWing 785.快速排序 题目描述 给定你一个长度为n的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式 输入共两行，第一行包含整数 n。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。 输出格式 输出共一行，包含 n 个整数，表示排好序的数列。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 5 3 1 2 4 5 输出样例： 1 2 3 4 5 这时候我们直接套用模板既可 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n , a[N]; void quick_sort(int q[] , int l , int r) { if(l &gt;= r) return; int x = q[l + r &gt;&gt; 1] , i = l - 1 , j = r + 1; while(i &lt; j) { do ++ i; while(q[i] &lt; x); do -- j; while(q[j] &gt; x); if(i &lt; j) swap(q[i] , q[j]); } quick_sort(q , l , j) , quick_sort(q , j + 1 , r); } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); quick_sort(a , 0 , n - 1); for(int j = 0; j &lt; n; ++ j) printf(&quot;%d &quot; , a[j]); return 0; } 大家在学算法的时候，特别是学习一个类型题的模板时可以隔三岔五地去敲了两三遍，当然不用追求和模板一致，因为模板是死的，人是活的，只要知道哪里可以变哪里不可以变，灵活运用即可 最后祝大家学习了算法之后，在刷题时能够游刃有余🤺🤺🤺 ","link":"https://solitudealma.github.io/post/quick_sort/"},{"title":"简单介绍一下递归","content":"今天我们来介绍一下递归😤 什么叫递归呢😩，其实说白了就是函数自己调用自己😲。如果还是不明白的小伙伴可以看看百度是怎么介绍的 =&gt;&gt; What is recursion 我第一次认识到递归是因为斐波那契数列。大致是这样的，有这么一个函数F(n)F(n)F(n)，当n=1n=1n=1或者n=2n=2n=2时F(n)=1F(n)=1F(n)=1,当n&gt;2n&gt;2n&gt;2时，F(n)=F(n−1)+F(n−2)F(n)=F(n-1)+F(n-2)F(n)=F(n−1)+F(n−2)。也就是n&gt;2n&gt;2n&gt;2时后面的每一项都等于前两项之和。 用代码来求第n项的话，可以这么写 #include &lt;iostream&gt; using namespace std; int n; int F(int a) { if(a == 0) return 0; else if(a == 1 || a == 2) return 1; //这两个if是递归结束的条件 else return F(a - 1) + F(a - 2); } int main() { cin &gt;&gt; n; cout &lt;&lt; F(n) &lt;&lt; endl; return 0; } 以上就是这简单的递归算法了。 这个代码并不难理解😏。 #include&lt;iostream&gt;这一头文件是C++新加的流输入输出，不懂的话也没关系，看作是scanf(&quot;%d&quot; , &amp;n);就行; using namespace std;也不难理解，C++将标准库中的标识符都放进了std这一命名空间中，为的是保证在同一命名空间中、相同作用域中任何名字都具有唯一性，即不重名。eg：上述代码中引用了iostream这一头文件里的cin函数，用于输入数据；如果不加上这句话，这时候编译器会提示你cin未定义（error: cin was not declared in this scope），相当于你没有引用头文件吧，emmm~~~（应该是这么理解的，大佬不要捶我）。了解过的同学可能会说直接使用命名空间是不太好的，因为你写的这个代码同样可能被其他代码当作头文件引用，会造成命名重复，应该使用什么就加上什么（std::cin）,但是这只是在做项目的时候才会有这种隐患，做题的时候有且只有一个cpp文件，而且你也不想每用一个就加上std吧2333 剩下的就是F这个函数了，递归其实挺好理解的，首先递归必须要有边界条件，否则将会无限递归下去直到栈满。那么你将收到oj（onlinejudge）的Memory Limit Exceeded（emmm，好像不一定是这个，反正意思一样就行），意思就是内存满了。这个边界就是当n=1n=1n=1或者n=2n=2n=2时函数返回1（其实也可以不用n=2,不过这样减到2时会多算一次），等于0就不用说了，直接告诉main函数调用F函数结束。 让我们来模拟一下这个递归，当我们输入的是4的时候，这时候a1=4a_1=4a1​=4,并不满足前面的条件，所以直接跳进else。但是要算F(4)F(4)F(4)的话得先算出F(3)+F(2)F(3) + F(2)F(3)+F(2)的值，这时候会再次调用F函数，（因为代码是从上而下执行的，所以代码暂时在这里停住了）调用后a2a_2a2​为3,要算F(3)F(3)F(3)就要先算F(2)+F(1)F(2) + F(1)F(2)+F(1),这时候又一次调用了F函数，但这一次不同了因为a3=2a_3=2a3​=2满足a=2a=2a=2这一条件，所以函数直接返回1，然后程序跳转到a2a_2a2​这一层调用中，F(3)=1+F(1)F(3) = 1 + F(1)F(3)=1+F(1),然后继续调用F函数，同样a4=1a_4=1a4​=1满足条件，函数返回1。接着又跳转回a2a_2a2​这一层调用，F(3)=1+1F(3) = 1 + 1F(3)=1+1,算完F(3)F(3)F(3)后继续算F(2)F(2)F(2),同样直接返回1，这样F(3)+F(2)F(3) + F(2)F(3)+F(2)就算完了，函数直接把结果返回给调用者，也就是main函数。在mian函数中输出F(4)F(4)F(4)的结果为3。至此递归就结束了。虽然理解起来挺复杂，但是认真地去模拟一下其实也没有想象的那么难（你以为就这？，不不不，还有更麻烦的递归，这只是最简单的一种）。 递归其实就相当于套娃一样一层一层地往下套，但是它返回结果的时候并不是从最上层开始的，而是从等于边界条件那一层开始逐级往上返回结果。有时候可以利用这一性质逆序输出数据2333。当然也不是递归就得返回数据，视情况而定（快速排序和归并排序的递归算法就不需要返回数据，直接修改数组的值就行了，因为习惯上把数组定义为全局变量，所以不需要数组当作参数传入或者是返回值返回） 但是类似这种递归其实当输入的数字大起来的时候是会重复计算的，所以可以适当优化一下，具体的自行百度~~~ 题解🙆‍♂ 下面给出一些常见的递归题目，也是非常简单的（因为列出数据就可以发现其实就是斐波那契数列。。。）。 1.问题描述：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少对？ 这题通过列出的数据可以发现第一个月只有1对，第二个月也只有1对，第三个月有2对，第四个月有3对，第五个月有5对。。。 所以我们直接用斐波那契数列的代码就行了🤙🤙🤙 #include &lt;iostream&gt; using namespace std; int n; int F(int a) { if(a == 0) return 0; else if(a == 1 || a == 2) return 1; else return F(a - 1) + F(a - 2); } int main() { cin &gt;&gt; n; cout &lt;&lt; F(n) &lt;&lt; endl; return 0; } 2.有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？（这题稍微有点不一样） 输入格式 输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。 输出格式 对于每个测试实例，请输出不同走法的数量 输入样例 2 2 3 输出样例 1 2 这个列出数据也可以发现，第一级的时候为0，第二级的时候为1，第三级的时候为2，第四级的时候为3。。。 所以对于0、1和2我们得处理一下。但是这里已经不可以用递归了，我是这么认为的 从列出的数据中可以发现，n=1n=1n=1时返回0，n=2n=2n=2时返回1，n=3n=3n=3时返回2就行了，n&gt;3n&gt;3n&gt;3时我们可以发现，输入的是4的话只需要加1次就可以得到结果了，5的话要加2次，以此类推，加的次数与输入的数只相差了3，那么我们把输入的数减去3赋值到一个变量中，用来表示我们要加的次数，然后将1与2用另外两个变量存起来，再定义一个变量用于存结果，以便返回。这时候我们只需要用while循环或者for循环即可做出这道题🤣🤣🤣 （其实这种两个变量的做法也可以顶替递归做斐波那契数列的题，思路是一样的） #include&lt;cstdio&gt; //定义常量，类似C中的#define N 100010 //比要求的数据范围多10是为了防止后续的操作导致溢出，反正内存一般是够用的，不差这几个 const int N = 100010 int arr[N]; int n; int F(int a) { int value = 0 , b = 1 , c = 2; if(a == 1) { return value; } else if(a == 2) { value = 1; return value; } else if(a == 3) { value = 2; return value; } else { a -= 3; while( a &gt; 0) -- a , value = b + c , b = c , c = value; return value; } } int main() { scanf(&quot;%d&quot; , &amp;n);//cin &gt;&gt; n; int i = 0 , temp; temp = n; //for(int i = 0; i &lt; n; ++ i) // cin &gt;&gt; a[i]; while(temp --) scanf(&quot;%d&quot; , &amp;arr[i]) , ++ i; int j = 0; //for(int j = 0; j &lt; n; ++ j) // cout &lt;&lt; a[j]; while(n --) printf(&quot;%d\\n&quot;,F(arr[j])) , ++ j; return 0; } 3.你要过河，但是没有桥，只有由一排石头堆成的石头路，你一次只能跨一个石头或者两个石头，求你到第n个石头有多少种走法。(这题也稍微有点不一样) 输入格式 正整数n 输出格式 可能性的个数 输入样例1 1 输出样例1 1 输入样例2 2 输出样例2 2 这题从列出的数据中可以发现，它其实是斐波那契数列往左边移了一位的数列。 所以我们直接上递归即可（不超时的情况下）🙂🙂🙂 #include&lt;iostream&gt; using namespace std; unsigned long long f(unsigned long long a) { if(a == 1) return 1; else if(a == 2) return 2; else return f(a - 1) + f(a - 2); } int main() { unsigned long long n; cin &gt;&gt; n; cout &lt;&lt; f(n); return 0; } 到这里递归就讲得差不多啦，如果还有小伙伴不是很理解的话，可以自行百度找题目去深入理解，或者直接用IDE去调试，调试的过程你就能明白递归的过程是怎样了。当然，还是不懂的话可以来找我击剑哦~~~🤺🤺🤺 那么今天的讲解就到此结束啦，See you again！！！🎉🎉🎉 ","link":"https://solitudealma.github.io/post/recursion/"}]}