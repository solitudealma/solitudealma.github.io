{"posts":[{"title":"题解：AcWing 792.高精度减法","content":"题目链接 AcWing 792.高精度减法 引用 题目描述 给定两个正整数，计算它们的差，计算结果可能为负数。 样例 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的差。 数据范围 1≤整数长度≤1051≤整数长度≤1051≤整数长度≤105 输入样例： 32 11 输出样例： 21 算法 (高精度减法) O(n)O(n)O(n) 高精度减法和加法区别不大，存储的时候我们也是倒序存入数组中，因为我们都知道，减法的过程中是会向前借位的，同样的，如果最高位是1，借位后为0，那么我们就不能够直接输出数组元素，必须先去掉前导零；还有就是因为减法是会产生负数，所以在计算之前我们应该先比较两个数的大小，通过数组长度以及从最高位开始对应位的大小；还有就是借位了，有一个很巧妙的计算借位相减后的数字， (t + 10) % 10 怎么理解呢， t存的是对应位相减的结果无论结果是正数还是负数，计算后都会得到正确的结果，然后根据t是否大于零来判断是否借位了。 负数记得输出负号哦~~~ 时间复杂度 O(n)O(n)O(n) 根据数的长度决定循环的次数，所以时间复杂度也是线性的 参考文献 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; bool cmp(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() != B.size()) return A.size() &gt; B.size(); for(int i = A.size() - 1; i &gt;= 0; i --) if(A[i] != B[i]) return A[i] &gt; B[i]; return true; } vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; A.size(); i ++) { t = A[i] - t; if(i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if(t &lt; 0) t = 1; else t = 0; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - '0'); vector&lt;int&gt; C; if(cmp(A , B)) C = sub(A , B); else C = sub(B , A) , cout &lt;&lt; '-'; for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; return 0; } ","link":"https://solitudealma.github.io/post/0gLrgnPR2/"},{"title":"高精度减法的介绍以及模板的分享","content":"今天我们来讲一下高精度减法 首先什么是高精度减法呢？☹️☹️☹️ 我们来看一下百度是怎么介绍高精度减法的,没想到百度居然偷懒，那我也顺带放上高精度加法的介绍吧。 也可以看看我之前对于高精度加法的介绍 高精度减法和加法区别不大，存储的时候我们也是倒序存入数组中，因为我们都知道，减法的过程中是会向前借位的，同样的，如果最高位是1，借位后为0，那么我们就不能够直接输出数组元素，必须先去掉前导零；还有就是因为减法是会产生负数，所以在计算之前我们应该先比较两个数的大小，通过数组长度以及从最高位开始对应位的大小；还有就是借位了，有一个很巧妙的计算借位相减后的数字， (t + 10) % 10 怎么理解呢， t存的是对应位相减的结果无论结果是正数还是负数，计算后都会得到正确的结果，然后根据t是否大于零来判断是否借位了。 负数记得输出负号哦~~~ 接下来我们来看看模板👇👇👇 bool cmp(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() != B.size()) return A.size() &gt; B.size();// 如果位数不相等，返回A &gt; B 的结果 // 遍历A与B的每一位，此时位数相同，用A或者B的size都行，只要有一位不同，就返回A[i] &gt; B[i] 的结果 for(int i = A.size() -1; i &gt;= 0; i --) if(A[i] != B[i]) return A[i] &gt; B[i]; return true; } vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C; // 存放结果 int t = 0; // 记录是否借位 for(int i = 0; i &lt; A.size(); i ++) { t = A[i] - t; //减去借位 if(i &lt; B.size()) t -= B[i]; //未减完就继续减 C.push_back((t + 10) % 10); //放入对应位结果 if(t &lt; 0) t = 1; //判断是否借位，小于零则借位 else t = 0; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); //去前导零 return C; } cmp函数是比较减数与被减数的大小，sub函数就是减法的具体内容了 模板内容就这么多，很好理解的，输出的时候记得倒序输出 那么我们来一道模板题练练手👏👏👏 AcWing 792. 高精度减法 题目描述 给定两个正整数，计算它们的差，计算结果可能为负数。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的差。 数据范围 1≤整数长度≤1051≤整数长度≤1051≤整数长度≤105 输入样例： 32 11 输出样例： 21 C++代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; bool cmp(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() != B.size()) return A.size() &gt; B.size(); for(int i = A.size() - 1; i &gt;= 0; i --) if(A[i] != B[i]) return A[i] &gt; B[i]; return true; } vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; A.size(); i ++) { t = A[i] - t; if(i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if(t &lt; 0) t = 1; else t = 0; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - '0'); vector&lt;int&gt; C; if(cmp(A , B)) C = sub(A , B); else C = sub(B , A) , cout &lt;&lt; '-' ; for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; return 0; } 引用 数组实现的看一看下面引用的题解；也有Java的实现方法，虽然Java有大数类；对压位感兴趣的小伙伴也可以看看🤺🤺🤺 师大专升本16级学长 AcWing 792. 高精度减法（C语言新手版） jasonlin AcWing 792. 高精度减法 小呆呆 AcWing 792. 高精度减法 Accepting AcWing 792. 高精度减法(压位) ","link":"https://solitudealma.github.io/post/OccoiC3O8/"},{"title":"题解 AcWing 791.高精度加法","content":"题目链接 AcWing 791. 高精度加法 引用 引用一下大佬的题解，其中有用数组实现的，也有Java的实现，也有string的实现以及压位，大佬们也太厉害了，orz~~~ lyclyc_NSP AcWing 791. 高精度加法C++数组实现 小呆呆 AcWing 791. 高精度加法 二月 AcWing 791. 高精度加法（使用string，30行） c++ 就是个渣渣 AcWing 791. 高精度加法 题目描述 给定两个正整数，计算它们的和。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的和。 数据范围 1≤整数长度≤1000001≤整数长度≤1000001≤整数长度≤100000 输入样例： 12 23 输出样例： 35 算法 (高精度加法) O(n)O(n)O(n) 高精度加法其实不难，首先我们肯定是存不下这个数的，所以可以用字符数组或者string读取，然后倒序存入vector中，加法计算过程只要注意进位即可，还有最高位可能要进位，所以需要判断一下 时间复杂度 O(n)O(n)O(n) 根据数的长度决定循环的次数，所以时间复杂度也是线性的 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; vector&lt;int&gt; add(vector&lt;int&gt; &amp;A ,vector&lt;int&gt; &amp;B) { if(A.size() &lt; B.size()) return add(B , A); vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; (int)A.size(); ++ i) { t += A[i]; if(i &lt; (int)B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; // a[i] - '0' 是通过ACII码的差值计算该字符转为数字时的大小 for(int i = a.size() - 1; i &gt;= 0; -- i) A.push_back(a[i] - '0'); for(int j = b.size() - 1; j &gt;= 0; -- j) B.push_back(b[j] - '0'); // auto是C++11的新特性，编译器会自动识别变量的类型，相当方便，如果不可以用，那就用标识符定义吧 auto C = add(A , B); for(int k = C.size() - 1; k &gt;= 0; -- k) cout &lt;&lt; C[k]; return 0; } ","link":"https://solitudealma.github.io/post/AcWing791/"},{"title":"高精度加法介绍以及模板的分享","content":"简单介绍一下高精度加法（高精度加高精度或低精度都可以用） 什么是高精度加法呢？🤣🤣🤣 简单点说就是当我们计算的时候，如果数据过大，那么我们使用的数据类型可能存不下，比如 int 的范围是 $-2^{31} $ ~ 231−12^{31}-1231−1（中间有个0），那么你存的数的位数不能超过9位数，但是很多时候数据都会很大，有些人会说，那我用 long 也行啊，我只能说有时候你用 unsigned long long 都不够，可见数据位数之长。 详情可以看看这个高精度算法😘😘😘 这里我们只解决高精度整数加法，一般也不考浮点数吧，emmm😜😜😜 那这种数据我们应该怎么处理呢？很简单。既然存不下，那我们就用字符串（字符数组也行，C++特有的数据类型string，其实也等价于字符数组，只不过更方便使用）读入，然后将其每一位存入数组中即可，只要我们的数组够大，就能完成我们的计算（不TLE的前提，既然题目明确要用这种方法就不会让你超时）。 但是对于加法我们都知道的一点，也是最重要的一点。那就是十进制数是满十进一，因为我们是用数组去存数的每一位，所以在计算的时候我们应该倒序存数的每一位，即数组的第一位存的不是最高位而是最低位，这样在我们进位的时候会更加方便（最高位可能也要进位，而这时数组第0位已经有数了，再放就越界了，得把数组中的数往后移，这样就会特别麻烦）。 那么我们先看看模板是怎样的👇👇👇 不知道vector的小伙伴可以看看这个vector介绍 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 vector&lt;int&gt; add(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() &lt; B.size()) return add(B , A);//如果被加数长度小于加数那么就调整顺序，如果不加这一句就需要变动一下for循环，i多判断一次是否小于B的大小（即算完最长的数的位数才停），然后 t += A[i] 用 if(i &lt; A.size())包裹 vector&lt;int&gt; C;// 定义一个答案 int t = 0; // 存储进位 for(int i = 0; i &lt; A.size(); ++ i) { t += A[i]; if(i &lt; B.size()) t += B[i]; //如果B还没加完就继续 C.push_back(t % 10); // mod 10 的结果就是对应位的结果 push_back 是往数组后面插入一个数 t /= 10; //整除10表示进位是多少 } if(t) C.push_back(c); // t为0，表示最高位无进位，大于0表示有进位。也可以写入for循环，自行思考 return C; } 这个模板并不难理解，输出答案的时候记得倒序输出就是了。 我们直接上模板题👇👇👇 AcWing 791. 高精度加法 题目描述 给定两个正整数，计算它们的和。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的和。 数据范围 1≤整数长度≤1000001≤整数长度≤1000001≤整数长度≤100000 输入样例： 12 23 输出样例： 35 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; vector&lt;int&gt; add(vector&lt;int&gt; &amp;A ,vector&lt;int&gt; &amp;B) { if(A.size() &lt; B.size()) return add(B , A); vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; (int)A.size(); ++ i) { t += A[i]; if(i &lt; (int)B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; // a[i] - '0' 是通过ACII码的差值计算该字符转为数字时的大小 for(int i = a.size() - 1; i &gt;= 0; -- i) A.push_back(a[i] - '0'); for(int j = b.size() - 1; j &gt;= 0; -- j) B.push_back(b[j] - '0'); // auto是C++11的新特性，编译器会自动识别变量的类型，相当方便，如果不可以用，那就用标识符定义吧 auto C = add(A , B); for(int k = C.size() - 1; k &gt;= 0; -- k) cout &lt;&lt; C[k]; return 0; } 引用 有大佬用数组写了一遍，可以参考，记得去前导零，因为开数组的时候都是比数据范围大，（emmm，其实也可以不用，不过写成函数的话可以搞个计数器，记录位数，然后输出2333，灵活运用吧），orz Java的小伙伴也可以学一下，貌似有些题目不能用Big Integer，毕竟算法这个东西学到一点是一点，不能因为语言特性而不去学 还有一点就是用数组貌似比STL快了一倍，不过这时差可以忽略不计，但是比如链表的操作这些用数组作为静态链表去模拟的话速度会快很多，而且写法也简单，特别是数据很大的时候，用数组往往是很好的选择，当然这也是后话了 对于压位感兴趣的小伙伴也可以试试，引用的题解中有，但是一般应该用不上 lyclyc_NSP AcWing 791. 高精度加法C++数组实现 小呆呆 AcWing 791. 高精度加法 二月 AcWing 791. 高精度加法（使用string，30行） c++ 就是个渣渣 AcWing 791. 高精度加法 ","link":"https://solitudealma.github.io/post/high_precision_addition/"},{"title":"题解 AcWing 790.数的三次方根","content":"题目链接 AcWing 790.数的三次方根 引用 引用一下还不错的题解 第一WA者金银花 AcWing 790. 数的三次方根 zning AcWing 790. 浮点数二分法_Java modeming AcWing 790. 数的三次方根（牛顿迭代法） 题目描述 给定一个浮点数n，求它的三次方根。 样例 输入格式 共一行，包含一个浮点数n。 输出格式 共一行，包含一个浮点数，表示问题的解。 注意，结果保留6位小数。 数据范围 −10000≤n≤10000−10000≤n≤10000−10000≤n≤10000 输入样例： 1000.001000.001000.00 输出样例： 10.00000010.00000010.000000 算法 (浮点数二分) O(n)O(n)O(n) 关于浮点数二分就没什么好说的了，因为精度问题，像三次方根平方根这些都只能找到大概的范围，所以我们只要不断缩小范围即可，设定一个精度eps，如果题目说精确到6位，那我们设置的精度就为 1e−81e-81e−8。 有一个需要注意的点是，求平方根时，如果输入的数是 &lt; 1 &amp;&amp; &gt;0，那么计算的时候就要注意了，比如0.1的平方根，那么答案肯定是在0.1到1之间，所以应该特殊处理区间更新方式 时间复杂度 O(n)O(n)O(n) 最多查找 n/2n/2n/2 次，所以时间复杂度是线性的 C++ 代码 #include &lt;cstdio&gt; using namespace std; double n; int main() { scanf(&quot;%lf&quot; , &amp;n); double l = -1000 , r = 1000 , eps = 1e-8; while(r - l &gt; eps) { double mid = (l + r) / 2; if(mid * mid * mid &gt;= n) r = mid; else l = mid; } printf(&quot;%.6lf&quot; , l); return 0; } ","link":"https://solitudealma.github.io/post/AcWing790/"},{"title":"2021.02.19 [日记]","content":"又是摸鱼的一天，一直睡到10点多才起床。起床后想到了可以给GitHub Pages改个自定义域名，u1s1，仓库名访问真的又臭又长，说干就干，百度了一下怎么操作。哦，越来加上A记录和CNAME记录就行啦，那简单，ping了一下原来的域名，搞到了ip，然后在仓库设置里填子域名即可，接着一通操作，ojbk。一访问，？？？，样式去哪了？出你妈大事。并且Github告诉我，我的DNS还未生效 Domain's DNS record could not be retrieved. 。然后我想了一下，可能是我配置的同时把DNS服务器从阿里云的改成了腾讯云。所以提示了这个？然后我又重新填了一边，发现，诶？可以正常访问了。晚上看了一下大佬的回答说是因为Github用了cdn，所以依然会有那个提示，具体原因不太清楚，反正能用就行2333。 昨晚帮一个初中生解决了个小问题，然后突然提到他朋友6年级就搭建了一个OJ平台和博客，初中搞信息奥赛的都是大佬，真的是后生可畏啊...当然别人厉害之余我们也应该多去学习，而不是停滞不前，毕竟比你牛的人都在努力，你又有什么理由不努力呢。当他说出OJ平台的时候我下意识的以为是评测系统，也就是测试数据的部分，毕竟刷过题的小伙伴都知道测试数据的部分不好搞，得限制时间和空间，测试结果不能返回过慢，多人同时测试时不能等待时间过长等等一系列优化问题。突然有一种想自己搞一个OJ平台的冲动，然后昨晚睡前简单的百度了一下，发现一个完整的OJ平台包括题库，比赛&amp;作业，排名等等，看来挺有搞头的，而且完成之后对于前后端开发都会有很大的提升。不过很大程度上做不完，哈哈哈。开学再看吧，溜了溜了。 ","link":"https://solitudealma.github.io/post/20200219/"},{"title":"题解：AcWing 789.数的范围","content":"题目链接 AcWing 789.数的范围 引用 引用一下我觉得还不错的题解，%%% 秦淮岸灯火阑珊 AcWing 789. 数的范围 Bug_FreeOωO AcWing 789. 数的范围 醉生梦死 AcWing 789. 二分算法的证明和边界分析 AdaMeta AcWing 789. 二分模板笔记 题目描述 给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。 对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。 如果数组中不存在该元素，则返回“-1 -1”。 样例 输入格式 第一行包含整数n和q，表示数组长度和询问个数。 第二行包含n个整数（均在1~10000范围内），表示完整数组。 接下来q行，每行包含一个整数k，表示一个询问元素。 输出格式 共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回“-1 -1”。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 1≤q≤100001≤q≤100001≤q≤10000 1≤k≤100001≤k≤100001≤k≤10000 输入样例： 6 3 1 2 2 3 3 4 3 4 5 输出样例： 3 4 5 5 -1 -1 算法 (二分) O(n)O(n)O(n) 相信大家在没有学习算法的时候多多少少都对二分法有一定的了解，二分法在查找的过程通过和区间中间值进行比较从而确定所找的值是中间值还是在左区间或是右区间。 一个题目，如果一个区间具有单调性质，那么一定可以二分，但是如果说这道题目没有单调性质，而是具有某种区间性质的话，我们同样可以使用二分。 ——yxc总 常见的可以二分的题 在区间中找一个数 本题中位置的最值即大于等于或小于等于某个值 某个东西是否存在 仔细分析题目意思2333 二分算法在选择区间时，选择的区间一定是存在答案的 做这道题可以直接上模板，但是模板有一些需要注意的地方 比如我们在 1223451 2 2 3 4 5122345 中找到2在序列中第一次出现的位置和最后一次出现的位置，首先我们先确定中间下标，将区间划分为左右两个区间，然后根据check函数判断来更新区间，因为我们需要寻找第一次出现的位置，所以check我们可以这么写 if(a[mid] &gt;= target) r = mid; ，那么最后一次出现就应该是 if(a[mid] &lt;= target) l = mid; 。这里要注意一点，为什么会有两个模板呢，因为区间的更新有两种情况，第一种就是左区间包含mid，第二种就是左区间不包含mid，而我们计算mid的时候是 l + r &gt;&gt; 1 ，当 l+1=rl + 1 = rl+1=r 并且是第二种划分情况时，如果依然是 l + r &gt;&gt; 1 的话，会造成死循环，也就是TLE，区间会一直停留在原地，所以左区间不包含mid时应该向上取整。 当然这两个模板无论哪一个都可以求你要找的那个数，所以如果只出现一次的话哪个都行，也就不存在无限循环的情况！！！ 贴上模板 bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 作者：yxc 链接：https://www.acwing.com/blog/content/277/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这里再说一下满足某种性质的区间，比如上面找2出现的位置，那么划分区间时，我们根据选的区间是否满足 &gt;=target&gt;= target&gt;=target 或者 &lt;=target&lt;= target&lt;=target 这一性质来判断我们找的数是不是在这个区间 时间复杂度 O(n)O(n)O(n) 最多查找 n/2n/2n/2 次，所以时间复杂度是线性的 C++ 代码 #include &lt;cstdio&gt; using namespace std; const int N = 1e5 + 10; int n , q; int a[N]; int main() { scanf(&quot;%d%d&quot; , &amp;n , &amp;q); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); while(q --) { int k; scanf(&quot;%d&quot; , &amp;k); int l = 0 , r = n - 1; while(l &lt; r) { int mid = l + r &gt;&gt; 1; if(a[mid] &gt;= k) r = mid; else l = mid + 1; } if(a[l] != k) printf(&quot;-1 -1\\n&quot;); else { printf(&quot;%d &quot; , l); l = 0 , r = n - 1;//l可更新可不更新 while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if(a[mid] &lt;= k) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot; , l); } } return 0; } ","link":"https://solitudealma.github.io/post/AcWing789/"},{"title":"题解：AcWing 788. 逆序对的数量","content":"题目链接 AcWing 788.逆序对的数量 引用 看了大佬的题解后对于归并又有了更深的理解，在这里引用一下dongwa_zzuli大佬的题解AcWing 788. 逆序对的数量，感兴趣的小伙伴可以看看 题目描述 给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。 逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。 样例 输入格式 第一行包含整数n，表示数列的长度。 第二行包含 n 个整数，表示整个数列。 输出格式 输出一个整数，表示逆序对的个数。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 6 2 3 4 5 6 1 输出样例： 5 算法 (归并排序) O(nlogn)O(nlogn)O(nlogn) 做这道题的话因为序列是不能被打乱的，而归并排序开始排序之前，序列还是原来的样子。根据这道题的性质我们可以发现，一共有三种情况，也就是这两个数的位置。 刚好在左区间 刚好在右区间 大的数在左区间，小的数在右区间 前两个情况很好求，在我们处理左右区间时就可以求出来，那么第三种呢。其实也不难，根据归并的性质可以知道在归并到最后一个区间的时候左右两个子区间是有序的，那么我们归并的时候可以判断一下，如果左指针所指的数大于右指针所指的数，那么左指针后的所有数都将大于它，那么这个数构成的逆序对就是 mid - i + 1 ，那么只需将所有这种情况加起来，再加上前两种情况就行了。前两种情况其实在合并为将它们分开时的那个区间时就已经计算完了，只需把 merge_sort(q , l , mid) 和 merge_sort(q , mid + 1 , r) 这两个结果加起来就行了，虽然看上去有点绕，但是如果你知道归并的过程的话，其实就能明白了，还是不太清楚的话建议手动模拟一下，也可以看看我画的图 其实这里还有一个很小的细节，因为我们需要存储逆序对的数量，当序列是倒序的时候逆序列是最多的，即对 n−1+n−2+n−3...+1n-1 + n-2 + n -3 ... + 1n−1+n−2+n−3...+1 ==&gt;&gt; ∑i=1nn\\sum_{i=1}^nn∑i=1n​n 也就是 n(n−1)2\\frac{n(n - 1)}{2}2n(n−1)​ ，当n为 1e51e51e5 时，逆序对的数量为 5×109−5×1045\\times10^9-5\\times10^45×109−5×104，已经超出int的范围了所以我们应该用long或者long long存 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 一共划分 lognlognlogn 次区间，每一层都是n次，所以时间复杂度是 O(nlogn)O(nlogn)O(nlogn) C++ 代码 #include &lt;cstdio&gt; using namespace std; typedef long long LL; const int N = 1e5 + 10; int n; int a[N]; LL merge_sort(int q[] , int l , int r) { if(l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_sort(q , l , mid) + merge_sort(q , mid + 1 , r); int i = l , j = mid + 1 , k = 0 , temp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(q[i] &lt;= q[j]) temp[k ++] = q[i ++]; else { res += mid - i + 1; temp[k ++] = q[j ++]; } } while(i &lt;= mid) temp[k ++] = q[i ++]; while(j &lt;= r) temp[k ++] = q[j ++]; for(int i = l , j = 0; i &lt;= r; ++ i , ++ j) q[i] = temp[j]; return res; } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); LL res = merge_sort(a , 0 , n - 1); printf(&quot;%lld&quot; , res); return 0; } ","link":"https://solitudealma.github.io/post/AcWing788/"},{"title":"题解：AcWing 786.第K个数","content":"题目链接 AcWing 786.第k个数 引用 星丶空大佬的题解，很不错的思路，奇怪的思路+1 并没有 写一个和yxc大佬不同但差不多思想的方法，代码更简单 题目描述 给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。 样例 输入格式 第一行包含两个整数 n 和 k。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整数数列。 输出格式 输出一个整数，表示数列的第k小数。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000, 1≤k≤n1≤k≤n1≤k≤n 输入样例： 5 3 2 4 1 5 3 输出样例： 3 算法 (快速选择) O(n)O(n)O(n) 从快排的性质可以知道，每次划分区间的时候j左边的数都是小于等于x的，右边的都是大于等于x的。所以如果左区间的长度大于等于k，那么第k个数必定在左区间，所以我们只需递归左区间，反过来，如果k大于左区间长度，那么第k个数在右区间，那么相对于右区间，第k个数在右区间中变为第（k - 左区间的长度）个数，然后递归右区间即可。 时间复杂度 O(n)O(n)O(n) emmm，问就是不知道怎么算的，不过肯定比 O(nlogn)O(nlogn)O(nlogn) 小，等我看了y总的时空复杂度分析再来补吧，哈哈哈 C++ 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int n , k; int a[N]; int quick_sort(int q[] , int l , int r , int k) { if(l &gt;= r) return q[l]; int i = l - 1 , j = r + 1 , x = q[l + r &gt;&gt; 1]; while(i &lt; j) { do ++ i; while(q[i] &lt; x); do -- j; while(q[j] &gt; x); if(i &lt; j) swap(q[i] , q[j]); } int len = j - l + 1; if(len &gt;= k) return quick_sort(q , l , j , k); else return quick_sort(q , j + 1 , r , k - len); } int main() { scanf(&quot;%d%d&quot; , &amp;n , &amp;k); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); int res = quick_sort(a , 0 , n - 1 , k); printf(&quot;%d&quot; , res); return 0; } ","link":"https://solitudealma.github.io/post/AcWing786/"},{"title":"对归并排序的一些理解","content":"今天我们来介绍一下归并排序 那么什么是归并排序呢？🤔🤔🤔 百度百科是这么说的:归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 也可以看看动态图😮😮😮 归并排序也和快速排序一样利用分治法来解决问题，同样它也采用了双指针算法（排序的时候），首先将一个有序或者无序的序列按中间索引（下标）分成两个部分，然后再将这两个部分继续分，直到区间长度为1。一个长度为n的区间一共需要分 log2nlog_2nlog2​n 次才能将区间分完。分完区间后就是对区间进行排序，然后合并区间即可。 因为一共需要分 log2nlog_2nlog2​n 次区间，所以归并排序的时间复杂度为 O(nlogn)O(nlogn)O(nlogn) 我们先来看看归并排序的模板👇👇👇 void merge_sort(int q[] , int l , int r) { if(l &gt;= r) return;//区间只有一个数的时候停止递归 int mid = l + r &gt;&gt; 1;//划分区间 merge_sort(q , l , mid) , merge_sort(q , mid + 1 , r);//递归划分左右区间 int i = l , j = mid + 1 , k = 0 , temp[r - l + 1];//i为左区间的指针，j为右区间的指针，k为排序的第几个数，temp数组用于合并区间时临时存储,temp也可以直接开一个和q一样大的全局变量，看个人喜好 //两个区间的数进行比较，小的或者相等的数将左区间的数放入temp，否则右区间放入 while(i &lt;= mid &amp;&amp; j &lt;= r) { if(q[i] &lt;= q[j]) temp[k ++] = q[i ++]; else temp[k ++] = q[j ++]; } // 因为存在还没比较完就有一个区间已经没有数了，所以将剩余的数全部放在temp后，一下while只有一个会执行 while(i &lt;= mid) temp[k ++] = q[i ++]; while(j &lt;= r) temp[k ++] = q[j ++]; for(int i = l , j = 0; i &lt;= r; ++ i , ++ j) q[i] = temp[j];//将temp数组更新到q数组中，q即为排序后的数组 } 归并排序的三个步骤 确定分界点 mid = l + r &gt;&gt; 1; 递归排序左右区间 归并区间❤️❤️❤️ 首先将区间一直划分，直到区间长度为1，接着排序左右区间，最后合并区间。 合并区间之前，区间一定是有序的 从左区间开始排序，此时区间中只有一个3，递归停止（只有一个元素不需要排序），排完后轮到右区间，此时区间中也是只有一个数，不需要排序，递归停止。跳回到上一层递归，然后排序3和1，因为本层递归将区间用mid划分了，也就是意义上的左右区间，形式上还是在同一个数组中，因为 q[i] = 3 是大于 q[j] = 1 的，所以将 q[j] 放入temp数组中，要注意这里的k++，++的位置意味着如果它在一个表达式中的话运算顺序是不一样的，除非它单独为一条语句，那它的位置在哪都一样，如果不能理解的话，单独拎出来自增也是可以的。然后此时 i &gt; mid ，所以while循环停止，接着把未比较完的数放进temp中，这样就合并完第一个区间了，然后更新q数组的前两个位置，如此往复就能把数组排序完了。 老规矩，自己手动模拟的话能更快的理解。 一些细节 k++和++k在单独的一个语句中并没有什么区别，k都会自增。但是如果在一个表达式中的话就不一样了，比如temp[k ++] = q[i ++],在这里是先用k和i的值，然后k和i再加1。我是这么记的，谁在前面谁先执行，即k++是先赋值后加1，++k是先加1后赋值 emmm,好像没有了，有的时候再加上吧 这个算法的难点在于合并区间，必定会有一个区间先比较完，然后得把剩余的所有数全部放入temp数组中，模板中的方法就很不错 又到了呈上例题的时候🤣🤣🤣 AcWing 787. 归并排序 题目描述 给定你一个长度为n的整数数列。 请你使用归并排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式 输入共两行，第一行包含整数 n。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。 输出格式 输出共一行，包含 n 个整数，表示排好序的数列。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 555 312453 1 2 4 531245 输出样例： 123451 2 3 4 512345 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 100010; int n; int a[N]; void merge_sort(int q[] , int l , int r) { if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q , l , mid) , merge_sort(q, mid + 1 , r); int i = l , j = mid + 1 , k = 0 , temp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(q[i] &lt;= q[j]) temp[k ++] = q[i ++]; else temp[k ++] = q[j ++]; } while(i &lt;= mid) temp[k ++] = q[i ++]; while(j &lt;= r) temp[k ++] = q[j ++]; for(int i = l , j = 0; i &lt;= r; ++ i , ++ j) q[i] = temp[j]; } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); merge_sort(a , 0 , n - 1); for(int i = 0; i &lt; n; ++ i) printf(&quot;%d &quot; , a[i]); return 0; } 以上就是我对归并算法的一些理解，如有错误的地方请大佬们指出。🤺🤺🤺 ","link":"https://solitudealma.github.io/post/merge_sort/"},{"title":"快速排序的介绍以及算法的模板分享","content":"今天我们来讲一下快速排序 那么什么是排序呢？🤔🤔🤔 百度百科是这么介绍的：快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 也可以看看动态图😮😮😮 它的主要思想是分治法，就是把一个问题分成相互独立的几个规模较小的子问题，然后逐一去解决，最终将得到“母问题的答案”。链接 ==&gt;&gt;分治法 今天我们将采用双指针算法去理解快速排序这一过程，对于双指针算法不太理解的小伙伴可以看看这个介绍 ==&gt;&gt; 算法 | 双指针套路总结 双指针算法基本原理和实践 因为我们是用数组去排序的，所以你只需要知道双指针代表着两个在改变的下标就行了（下标访问本质上也是指针）。 快排的平均时间复杂度为O(nlog2n)O(nlog_2n)O(nlog2​n)，最糟糕的时候是O(n2)O(n^2)O(n2)。 首先我们先给出我们的快排模板👇👇👇 void quick_sort(int q[] , int l , int r) { if(l &gt;= r) return; //表示此区间只有一个数或者没有数 int i = l - 0 , j = r + 1 , x = q[l + r &gt;&gt; 1]; //i为左指针，j为右指针 x为每一次分割区间时选定的比较数 &gt;&gt; 这个是右移运算符，是位运算的一种，将一个整数右移一位表示除以2 while(i &lt; j) { do ++ i; while(q[i] &lt; x); //左指针寻找小于x的数 do -- j; while(q[j] &gt; x); //右指针寻找大于x的数 if(i &lt; j) swap(q[i] &lt; q[j]); //swap函数存在于C++的algorithm头文件中，相当于自己手写的交换变量函数，因为指针停下来的时候可能是穿过，重合这两种情况其中一种，如果未相遇我们就交换指针所指的数，然后直到l&gt;=r循环结束 } //每一次递归之后i、j的相对位置只有两种情况，i==j或者i==j+1 quick_sort(q , l , j) , quick_sort(q , j + 1 , r);//递归处理左右区间，先左，再右（注意划分区间用的是i还是j） } 好了，以上就是我们要用到的快排模板了，一个好的模板能让你快速记忆一个算法，同时它也已经帮我们解决了烦人的边界问题，只需要好好理解记忆即可 快排的三个步骤 确定分界点 q[l] , q[l + r &gt;&gt; 1] , q[r] , 随机 调整区间 保证左边小于等于x，右边大于等于x，x在哪一边都可以❤️❤️❤️ 递归处理左右两段 这个模板其实不难理解，函数传入一个含有n个元素的有序或者无序的序列，我们用分治法的思想，首先先确定分界点，因为选取的是l + r &gt;&gt; 1也就是中间元素；而后寻找满足条件的数，直到 l&gt;=rl &gt;= rl&gt;=r ,接着调整区间，将其分为&gt;=x&gt;=x&gt;=x和&lt;=x&lt;=x&lt;=x的两个区间（用j划分，j的左边一定小于等于x，j的右边一定大于等于x）；最后再递归处理左右区间。 如果一个区间只有一个元素，而这个区间又满足小于等于x或者大于等于x这一条件，那么整个合并的区间都是有序的。 一共需要分log2nlog_2nlog2​n次,在第log2nlog_2nlog2​n次时每一个元素都在一个区间里，在那个区间中它是有序的。也是至此递归不再继续，因为区间中只有一个元素（ l&gt;=rl &gt;= rl&gt;=r ），还是不明白的小伙伴可以动手模拟一下，画一下图会清晰很多 一些细节 i , j 指针每次都在区间之外，这是因为我们用了do-while循环，每一次指针都是先+1/-1，再判断，这样可以避免死循环等一些迷之操作（其实一般来说都是先判断再操作，这样的话避免回退操作，这里用do-while循环是为了方便理解） 选取元素的作为比较的值时尽量不要选取左右端点，因为当序列有序时，时间复杂度会退化为O(n2)O(n^2)O(n2) 如果选取右端点，则递归处理的代码为quick_sort(q , l , i - 1) , quick_sort(q , i , r);;如果选的是左端点，则为quick_sort(q , l , j) , quick_sort(q , j + 1 , r);；如果选取中间点，两种都可以哦 一切有关边界问题的算法都建议背模板，因为这是经过n位大佬试验过的，只需要记就行了 如果用的时候无论如何都想不起快排的模板的话，还有一个暴力的方式。1.首先我们先创建a，b两个数组；2.遍历数组q，小于等于x的数放入a中，其他的放入b中；3.将a，b分别排序后，先将a中的元素放入q，再将b中的元素放入q即可 这个算法难点在于调整区间,以j来划分区间的话，在j左边的数都小于等于x，在右边的都大于等于x，其他同理，应该注意你用的是i还是j来划分区间 附上一个简单的快速排序图解 现在我们来写一道模板题 AcWing 785.快速排序 题目描述 给定你一个长度为n的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式 输入共两行，第一行包含整数 n。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。 输出格式 输出共一行，包含 n 个整数，表示排好序的数列。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 5 3 1 2 4 5 输出样例： 1 2 3 4 5 这时候我们直接套用模板既可 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n , a[N]; void quick_sort(int q[] , int l , int r) { if(l &gt;= r) return; int x = q[l + r &gt;&gt; 1] , i = l - 1 , j = r + 1; while(i &lt; j) { do ++ i; while(q[i] &lt; x); do -- j; while(q[j] &gt; x); if(i &lt; j) swap(q[i] , q[j]); } quick_sort(q , l , j) , quick_sort(q , j + 1 , r); } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); quick_sort(a , 0 , n - 1); for(int j = 0; j &lt; n; ++ j) printf(&quot;%d &quot; , a[j]); return 0; } 大家在学算法的时候，特别是学习一个类型题的模板时可以隔三岔五地去敲了两三遍，当然不用追求和模板一致，因为模板是死的，人是活的，只要知道哪里可以变哪里不可以变，灵活运用即可 最后祝大家学习了算法之后，在刷题时能够游刃有余🤺🤺🤺 ","link":"https://solitudealma.github.io/post/quick_sort/"},{"title":"简单介绍一下递归","content":"今天我们来介绍一下递归😤 什么叫递归呢😩，其实说白了就是函数自己调用自己😲。如果还是不明白的小伙伴可以看看百度是怎么介绍的 =&gt;&gt; What is recursion 我第一次认识到递归是因为斐波那契数列。大致是这样的，有这么一个函数F(n)F(n)F(n)，当n=1n=1n=1或者n=2n=2n=2时F(n)=1F(n)=1F(n)=1,当n&gt;2n&gt;2n&gt;2时，F(n)=F(n−1)+F(n−2)F(n)=F(n-1)+F(n-2)F(n)=F(n−1)+F(n−2)。也就是n&gt;2n&gt;2n&gt;2时后面的每一项都等于前两项之和。 用代码来求第n项的话，可以这么写 #include &lt;iostream&gt; using namespace std; int n; int F(int a) { if(a == 0) return 0; else if(a == 1 || a == 2) return 1; //这两个if是递归结束的条件 else return F(a - 1) + F(a - 2); } int main() { cin &gt;&gt; n; cout &lt;&lt; F(n) &lt;&lt; endl; return 0; } 以上就是这简单的递归算法了。 这个代码并不难理解😏。 #include&lt;iostream&gt;这一头文件是C++新加的流输入输出，不懂的话也没关系，看作是scanf(&quot;%d&quot; , &amp;n);就行; using namespace std;也不难理解，C++将标准库中的标识符都放进了std这一命名空间中，为的是保证在同一命名空间中、相同作用域中任何名字都具有唯一性，即不重名。eg：上述代码中引用了iostream这一头文件里的cin函数，用于输入数据；如果不加上这句话，这时候编译器会提示你cin未定义（error: cin was not declared in this scope），相当于你没有引用头文件吧，emmm~~~（应该是这么理解的，大佬不要捶我）。了解过的同学可能会说直接使用命名空间是不太好的，因为你写的这个代码同样可能被其他代码当作头文件引用，会造成命名重复，应该使用什么就加上什么（std::cin）,但是这只是在做项目的时候才会有这种隐患，做题的时候有且只有一个cpp文件，而且你也不想每用一个就加上std吧2333 剩下的就是F这个函数了，递归其实挺好理解的，首先递归必须要有边界条件，否则将会无限递归下去直到栈满。那么你将收到oj（onlinejudge）的Memory Limit Exceeded（emmm，好像不一定是这个，反正意思一样就行），意思就是内存满了。这个边界就是当n=1n=1n=1或者n=2n=2n=2时函数返回1（其实也可以不用n=2,不过这样减到2时会多算一次），等于0就不用说了，直接告诉main函数调用F函数结束。 让我们来模拟一下这个递归，当我们输入的是4的时候，这时候a1=4a_1=4a1​=4,并不满足前面的条件，所以直接跳进else。但是要算F(4)F(4)F(4)的话得先算出F(3)+F(2)F(3) + F(2)F(3)+F(2)的值，这时候会再次调用F函数，（因为代码是从上而下执行的，所以代码暂时在这里停住了）调用后a2a_2a2​为3,要算F(3)F(3)F(3)就要先算F(2)+F(1)F(2) + F(1)F(2)+F(1),这时候又一次调用了F函数，但这一次不同了因为a3=2a_3=2a3​=2满足a=2a=2a=2这一条件，所以函数直接返回1，然后程序跳转到a2a_2a2​这一层调用中，F(3)=1+F(1)F(3) = 1 + F(1)F(3)=1+F(1),然后继续调用F函数，同样a4=1a_4=1a4​=1满足条件，函数返回1。接着又跳转回a2a_2a2​这一层调用，F(3)=1+1F(3) = 1 + 1F(3)=1+1,算完F(3)F(3)F(3)后继续算F(2)F(2)F(2),同样直接返回1，这样F(3)+F(2)F(3) + F(2)F(3)+F(2)就算完了，函数直接把结果返回给调用者，也就是main函数。在mian函数中输出F(4)F(4)F(4)的结果为3。至此递归就结束了。虽然理解起来挺复杂，但是认真地去模拟一下其实也没有想象的那么难（你以为就这？，不不不，还有更麻烦的递归，这只是最简单的一种）。 递归其实就相当于套娃一样一层一层地往下套，但是它返回结果的时候并不是从最上层开始的，而是从等于边界条件那一层开始逐级往上返回结果。有时候可以利用这一性质逆序输出数据2333。当然也不是递归就得返回数据，视情况而定（快速排序和归并排序的递归算法就不需要返回数据，直接修改数组的值就行了，因为习惯上把数组定义为全局变量，所以不需要数组当作参数传入或者是返回值返回） 但是类似这种递归其实当输入的数字大起来的时候是会重复计算的，所以可以适当优化一下，具体的自行百度~~~ 题解🙆‍♂ 下面给出一些常见的递归题目，也是非常简单的（因为列出数据就可以发现其实就是斐波那契数列。。。）。 1.问题描述：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少对？ 这题通过列出的数据可以发现第一个月只有1对，第二个月也只有1对，第三个月有2对，第四个月有3对，第五个月有5对。。。 所以我们直接用斐波那契数列的代码就行了🤙🤙🤙 #include &lt;iostream&gt; using namespace std; int n; int F(int a) { if(a == 0) return 0; else if(a == 1 || a == 2) return 1; else return F(a - 1) + F(a - 2); } int main() { cin &gt;&gt; n; cout &lt;&lt; F(n) &lt;&lt; endl; return 0; } 2.有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？（这题稍微有点不一样） 输入格式 输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。 输出格式 对于每个测试实例，请输出不同走法的数量 输入样例 2 2 3 输出样例 1 2 这个列出数据也可以发现，第一级的时候为0，第二级的时候为1，第三级的时候为2，第四级的时候为3。。。 所以对于0、1和2我们得处理一下。但是这里已经不可以用递归了，我是这么认为的 从列出的数据中可以发现，n=1n=1n=1时返回0，n=2n=2n=2时返回1，n=3n=3n=3时返回2就行了，n&gt;3n&gt;3n&gt;3时我们可以发现，输入的是4的话只需要加1次就可以得到结果了，5的话要加2次，以此类推，加的次数与输入的数只相差了3，那么我们把输入的数减去3赋值到一个变量中，用来表示我们要加的次数，然后将1与2用另外两个变量存起来，再定义一个变量用于存结果，以便返回。这时候我们只需要用while循环或者for循环即可做出这道题🤣🤣🤣 （其实这种两个变量的做法也可以顶替递归做斐波那契数列的题，思路是一样的） #include&lt;cstdio&gt; //定义常量，类似C中的#define N 100010 //比要求的数据范围多10是为了防止后续的操作导致溢出，反正内存一般是够用的，不差这几个 const int N = 100010 int arr[N]; int n; int F(int a) { int value = 0 , b = 1 , c = 2; if(a == 1) { return value; } else if(a == 2) { value = 1; return value; } else if(a == 3) { value = 2; return value; } else { a -= 3; while( a &gt; 0) -- a , value = b + c , b = c , c = value; return value; } } int main() { scanf(&quot;%d&quot; , &amp;n);//cin &gt;&gt; n; int i = 0 , temp; temp = n; //for(int i = 0; i &lt; n; ++ i) // cin &gt;&gt; a[i]; while(temp --) scanf(&quot;%d&quot; , &amp;arr[i]) , ++ i; int j = 0; //for(int j = 0; j &lt; n; ++ j) // cout &lt;&lt; a[j]; while(n --) printf(&quot;%d\\n&quot;,F(arr[j])) , ++ j; return 0; } 3.你要过河，但是没有桥，只有由一排石头堆成的石头路，你一次只能跨一个石头或者两个石头，求你到第n个石头有多少种走法。(这题也稍微有点不一样) 输入格式 正整数n 输出格式 可能性的个数 输入样例1 1 输出样例1 1 输入样例2 2 输出样例2 2 这题从列出的数据中可以发现，它其实是斐波那契数列往左边移了一位的数列。 所以我们直接上递归即可（不超时的情况下）🙂🙂🙂 #include&lt;iostream&gt; using namespace std; unsigned long long f(unsigned long long a) { if(a == 1) return 1; else if(a == 2) return 2; else return f(a - 1) + f(a - 2); } int main() { unsigned long long n; cin &gt;&gt; n; cout &lt;&lt; f(n); return 0; } 到这里递归就讲得差不多啦，如果还有小伙伴不是很理解的话，可以自行百度找题目去深入理解，或者直接用IDE去调试，调试的过程你就能明白递归的过程是怎样了。当然，还是不懂的话可以来找我击剑哦~~~🤺🤺🤺 那么今天的讲解就到此结束啦，See you again！！！🎉🎉🎉 ","link":"https://solitudealma.github.io/post/recursion/"}]}