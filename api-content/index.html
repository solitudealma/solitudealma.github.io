{"posts":[{"title":"Nodejs-Mongodb模块常用的操作封装","content":"之前写了一篇文章是关于nodejs mongodb模块的一些简单Demo，但是如果是需要结合项目一起使用的话，那肯定是对其进行二次封装是最好的，这样能方便自己，也能学到一些东西。 所以依照网上的一些文章和官方文档简单地封装了一下。虽然说调用起来并没有多大的区别，但至少我们把重复的部门提炼出来，定义为函数，调用起来显得更方便。结合Promise能更大程度降低代码的复杂性，脱离回调地狱，使代码显得不那么臃肿。 个人觉得模块的封装并不是说一定要最大限度地简化方法的调用之类的，比如说你只是独立一个小功能，那么你只需要把接口之类的暴露出来就行了；如果是想数据库操作的模块封装那么可以考虑简化一下数据库语言的书写（比如MySQL），但这只是自己使用的时候有用，团队开发最好不要这么干，当然这么做也有其意义，能学到更深层面的东西。 在找文章的时候看到了一个人用prototype这个属性来封装模块，之前看到的封装都是直接定义一个对象，然后添加方法等 moudule.exports = { insertOne() {}, insertMany() {} .... } 上面用到了ES6语法的属性名简介表示，详情可以看看这个 ECMAScript 6 入门 ，在对象扩展部分。本次封装用了一些ES6的语法，看不懂的话可以去链接里找找 那么什么是prototype呢？JavaScript中的prototype是一个原型对象，那么什么是原型呢？在这里我们不做详细的解释，感兴趣的小伙伴可以去百度找找答案。我们都知道，js中函数也是一个对象，emmm，其中牵扯有点大，貌似涉及原型原型链，暂且这么认为吧。 我们都知道，已存在的对象的构造器中是不能添加新的属性，除非在构造器中添加。 所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法： Date 对象从 Date.prototype 继承。 Array 对象从 Array.prototype 继承。 Person 对象从 Person.prototype 继承。 所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。 JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。 Date 对象, Array 对象, 以及 Person 对象从 Object.prototype 继承。 添加属性和方法 有的时候我们想要在所有已经存在的对象添加新的属性或方法。 另外，有时候我们想要在对象的构造函数中添加属性或方法。 -----菜鸟教程 那么我们就可以通过prototype来为一个对象添加属性与方法 说了这么多，直接上代码吧 const { MongoClient } = require(&quot;mongodb&quot;); const connectionConfig = { host: 'localhost', username: '', password: '', port: '27017', database: '', authMechanism: 'DEFAULT' }; // 某版本之后规定用户名密码需要URI编码 const username = encodeURIComponent(connectionConfig.username); const password = encodeURIComponent(connectionConfig.password); // 实例化db对象 const db = function () { this.dbClient = null; this.MongoClient = null; }; db.prototype.getConnection = function () { return new Promise((resolve, reject) =&gt; { if (!this.dbClient) { if (connectionConfig.username != '' &amp;&amp; connectionConfig.password != '') { let url = `mongodb://${username}:${password}@${connectionConfig.host}:${connectionConfig.port}/?authMechanism=${connectionConfig.authMechanism}`; try { let mongoClient = new MongoClient(url, { useNewUrlParser: true, useUnifiedTopology: true, poolSize: 10, authSource: connectionConfig.database, // user : connectionConfig.username, // password : connectionConfig.password, 不是必须 authMechanism: connectionConfig.authMechanism }); this.MongoClient = mongoClient; mongoClient.connect(); this.dbClient = mongoClient.db(connectionConfig.database); resolve(this.dbClient); } catch (error) { reject(error); } } else { let url = `mongodb://${connectionConfig.host}:${connectionConfig.port}/`; try { let mongoClient = new MongoClient(url, { useNewUrlParser: true, useUnifiedTopology: true }); this.MongoClient = mongoClient; mongoClient.connect(); this.dbClient = mongoClient.db(connectionConfig.database); resolve(this.dbClient); } catch (error) { reject(error); } } } resolve(this.dbClient); }); } /** * 插入一个文档 * @param collection_name 集合名称 * @param obj 插入的文档数据 * @param options 一些可选操作 */ db.prototype.insertOne = async function (collectionName, obj, options) { options = options || {}; return new Promise((resolve, reject) =&gt; { this.getConnection().then(e =&gt; { e.collection(collectionName).insertOne(obj, options, (err, res) =&gt; { if (err) reject(err); this.MongoClient.close(); this.MongoClient = this.dbClient = null; resolve(res); }); }).catch(error =&gt; reject(error)); }); } /** * 插入多个文档 * @param collection_name 集合名称 * @param arr 插入的文档数据集合 * @param options 一些可选操作 * * option: * ordered:如果为true，则在插入失败时，不要执行其余的写操作。 如果为false，则在失败时继续执行其余的插入操作。 */ db.prototype.insertMany = async function (collectionName, arr, options) { return new Promise((resolve, reject) =&gt; { options = options || {}; this.getConnection().then(e =&gt; { e.collection(collectionName).insertMany(arr, options, (err, res) =&gt; { if (err) reject(err); this.MongoClient.close(); this.MongoClient = this.dbClient = null; resolve(res); }); }).catch(error =&gt; reject(error)); }); } /** * 查找文档（范围不止一条） * @param collection_name 集合名称 * @param obj 查询数据的一些操作信息 * 传空对象会查询集合所有数据 * obj: * whereObj:条件，默认是{} * options: * projection:指定字段 0不显示 1显示 * sort:排序，默认是{} * limit:显示提定条数,默认是0 * skip:跳过指定条数，默认是0 * * js中逻辑与和其他语言不太一样，如果第一个操作数是true(或者能够转为true)， * 计算结果就是第二个操作数，如果第一个操作数是false，结果就是false（短路计算）， * 对于一些特殊数值不遵循以上规则. * * ObjectID 生成系统自动生成的_id * sort也可以写进option * * 以下写法等价 * collection.find({ runtime: { $lt: 15 } }, { sort: { title: 1 }, projection: { _id: 0, title: 1, imdb: 1 }}); * collection.find({ runtime: { $lt: 15 } }).sort({ title: 1}).project({ _id: 0, title: 1, imdb: 1 }); **/ db.prototype.find = async function (collectionName, obj) { return new Promise((resolve, reject) =&gt; { obj.whereObj = obj.whereObj || {}; obj.options = obj.options || {}; obj.limit = obj.limit || 0; obj.skip = obj.skip || 0; this.getConnection().then(e =&gt; { e.collection(collectionName) .find(obj.whereObj, obj.options) .sort(obj.sortObj) .limit(obj.limit) .skip(obj.skip) .toArray((err, res) =&gt; { if (err) reject(err); this.MongoClient.close(); this.MongoClient = this.dbClient = null; resolve(res); }); }).catch(error =&gt; reject(error)); }); } /** * 修改单个文档 * @param collection_name 集合名称 * @param obj 修改数据的一些操作信息 * @param options 一些可选操作 * obj: * whereObj:条件，默认是{} * updateObj:修改语句，NOT NULL * * 还有很多操作，但必须加上$xxx * 如果应用程序在更新后需要文档，请考虑使用 collection.findOneAndUpdate()。方法，该方法具有与 updateOne ()类似的接口，但也返回原始文档或更新的文档。 * updateOne和updateMany与update不同，需要加上$操作（Update document requires atomic operators）$set $inc **/ db.prototype.updateOne = async function (collectionName, obj, options) { obj.whereObj = obj.whereObj || {}; obj.updateObj = obj.updateObj || {}; options = options || {}; return new Promise((resolve, reject) =&gt; { this.getConnection().then(e =&gt; { e.collection(collectionName) .updateOne(obj.whereObj, obj.updateObj, options, (err, res) =&gt; { if (err) reject(err); this.MongoClient.close(); this.MongoClient = this.dbClient = null; resolve(res); }); }).catch(error =&gt; reject(error)); }); } /** * 修改多个文档 * @param collection_name 集合名称 * @param obj 修改数据的一些操作信息 * @param options 一些可选操作 * obj: * whereObj:条件，默认是{} * updateObj:修改语句，NOT NULL * * 还有很多操作，但必须加上$xxx * updateOne和updateMany与update不同，需要加上$操作（Update document requires atomic operators） $set $inc **/ db.prototype.updateMany = async function (collectionName, obj, options) { obj.whereObj = obj.whereObj || {}; obj.updateObj = obj.updateObj || {}; options = options || {}; return new Promise((resolve, reject) =&gt; { this.getConnection().then(e =&gt; { e.collection(collectionName) .updateMany(obj.whereObj, obj.updateObj, options, (err, res) =&gt; { if (err) reject(err); this.MongoClient.close(); this.MongoClient = this.dbClient = null; resolve(res); }); }).catch(error =&gt; reject(error)); }); } /** * 替换单个文档 * @param collection_name 集合名称 * @param obj 修改数据的一些操作信息 * @param options 一些可选操作 * obj: * whereObj:条件，默认是{} * updateObj:修改语句，NOT NULL * * replaceOne ()接受查询文档和替换文档。如果查询与集合中的某个文档匹配，它将用提供的替换文档替换匹配该查询的第一个文档。此操作删除原始文档中的所有字段和值，并用替换文档中的字段和值替换它们。除非在替换文档中为 _ id 显式指定一个新值，否则 _ id 字段的值保持不变。 **/ db.prototype.replaceOne = async function (collectionName, obj, options) { obj.whereObj = obj.whereObj || {}; obj.updateObj = obj.updateObj || {}; options = options || {}; return new Promise((resolve, reject) =&gt; { this.getConnection().then(e =&gt; { e.collection(collectionName) .replaceOne(obj.whereObj, obj.updateObj, options, (err, res) =&gt; { if (err) reject(err); this.MongoClient.close(); this.MongoClient = this.dbClient = null; resolve(res); }); }).catch(error =&gt; reject(error)); }); } /** * 删除单个文档 * @param collection_name 集合名称 * @param obj 修改数据的一些操作信息 * @param options 一些可选操作 * obj: * whereObj:条件，NOT NULL，为空会删除第一条 * * 如果不提供查询文档(或者提供空文档) ，MongoDB 将匹配集合中的所有文档并删除第一个匹配。 * 如果应用程序在删除后需要被删除的文档，请考虑使用 collection.findOneAndDelete ()。方法，它具有与 deleteOne ()类似的接口，但也返回被删除的文档。 * **/ db.prototype.deleteOne = async function (collectionName, obj, options) { obj.whereObj = obj.whereObj; options = options || {}; return new Promise((resolve, reject) =&gt; { this.getConnection().then(e =&gt; { e.collection(collectionName) .deleteOne(obj.whereObj, options, (err, res) =&gt; { if (err) reject(err); this.MongoClient.close(); this.MongoClient = this.dbClient = null; resolve(res); }); }).catch(error =&gt; reject(error)); }); } /** * 删除多个文档 * @param collection_name 集合名称 * @param obj 修改数据的一些操作信息 * @param options 一些可选操作 * obj: * whereObj:条件，NOT NULL，为空会删除第一条除_id外的数据 * * 如果不提供查询文档(或者提供空文档) ，MongoDB 将匹配集合中的所有文档并删除它们。 * 虽然可以使用 deleteMany ()删除集合中的所有文档，但是为了获得更好的性能和更清晰的代码，可以考虑使用 drop ()。 * **/ db.prototype.deleteMany = async function (collectionName, obj, options) { obj.whereObj = obj.whereObj; options = options || {}; return new Promise((resolve, reject) =&gt; { this.getConnection().then(e =&gt; { e.collection(collectionName) .deleteMany(obj.whereObj, options, (err, res) =&gt; { if (err) reject(err); this.MongoClient.close(); this.MongoClient = this.dbClient = null; resolve(res); }); }).catch(error =&gt; reject(error)); }); } /** * 左连接 * @param collection_name 集合名称 * @param arr 左连接所需的参数 * arr: * from:右集合 * localField:左集合 join 字段 * foreignField:右集合 join 字段 * as:新生成字段（类型array） * **/ db.prototype.aggregate = async function (collectionName, arr) { return new Promise((resolve, reject) =&gt; { this.getConnection().then(e =&gt; { e.collection(collectionName) .aggregate(arr) .toArray((err, res) =&gt; { if (err) reject(err); this.MongoClient.close(); this.MongoClient = this.dbClient = null; resolve(res); }); }).catch(error =&gt; reject(error)); }); } module.exports = new db(); 参考以下文章 Node.js操作MongoDB数据库的基本用法 nodejs操作mongodb数据库封装DB类 Node.js封装对mongodb操作的模块 NodeJS操作 Mongodb 并且对 Mongodb 类库进行封装 ","link":"https://solitudealma.github.io/post/nXQ9P_Lo2/"},{"title":"Nodejs-Mongodb的一些简单的CURD","content":"最近放下了算法的学习，重新拾起了开发。刚好想搞点小玩意，因为学算法暂时搁置了。思来想去觉得用Mongodb这个数据库更好一点，query的数据刚好是一个json，而nodejs对json的支持堪称完美。 因为初次使用这个模块，所以简单的实现了一下Mongodb的CURD 刚开始按照自上而下的顺序写的时候发现顺序并不是我想要的，查询的时候查到了空数组。这说明了什么，异步问题，代码不能保证执行顺序，虽然相差不大，但刚好不是我们想要的顺序，而且随着业务的问题，一次操作的数据可能非常大，那样对于顺序的把控更加不可靠了，那么应该怎么办呢 ES6有两个新特性，一个是Promise对象，一个async函数。Promise可以简化代码，让你的代码脱离回调地狱，毕竟这种俄罗斯套娃式的代码任谁看了都不好受。async是对异步操作的一种改进。 具体的可以看看这个ES6 入门教程 当然，安装部分就不给出了，这个有手就行，百度一下你就知道 这里只实现了插入查询操作，余下的感兴趣的小伙伴可以看看菜鸟教程 const { MongoClient } = require(&quot;mongodb&quot;); const dbName = &quot;test&quot;; const uri = &quot;mongodb://localhost:27017/&quot; + dbName; // 这里按照官方3.x示例更改了一下 const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true }); // 与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。所以建立连接的时候直接指定数据库和集合即可 // 在这里我们使用ES6语法，它有很多很好用的新特性，比如接下来我们要用到的async，await，Promise，箭头函数，let，const等 // 因为我们这些操作都是写在一个函数里，所以每一次操作之后就不断开连接了，这样就挺麻烦的。但是在写项目的时候，对于数据库的操作一般都是在接口上，所以我们每次操作完之后记得释放资源，如果封装的模块会自动释放那最好 // 连接数据库 async function connectDb(client, dbName) { return new Promise(async function (resolve, reject) { await client.connect(); let database = client.db(dbName); resolve(database); }); } // 这个可有可无，最好就不要写，因为可能重复创建，会报错，直接连接就行，或者自己手动创建，因为它不能像MySQL那样去检测是否存在 // async function createColl(database , collName) { // return new Promise((resolve , reject) =&gt; { // database.createCollection(collName , (err , res) =&gt; { // if (err) reject(err); // resolve(); // }); // }) // } // 连接集合 function connectColl(database, collName) { return new Promise((resolve, reject) =&gt; { let collObj = database.collection(collName); resolve(collObj); }); } // 插入一条数据 function insert(collObj, obj) { return new Promise((resolve, reject) =&gt; { collObj.insertOne(obj, (err, res) =&gt; { if (err) reject(err); resolve(); }); }); } // 插入多条数据 function insertM(collObj, arr) { return new Promise((resolve, reject) =&gt; { collObj.insertMany(arr, (err, res) =&gt; { if (err) reject(err); resolve(); }); }); } // 查找数据 function findData(collObj, obj) { return new Promise((resolve, reject) =&gt; { // 将返回的数据转换为数组 let res = collObj.find(obj).toArray(); if (!res) reject(&quot;Not Found!&quot;); else resolve(res); }); } async function run() { try { let database = await connectDb(client, dbName); let collName = &quot;testColl&quot;; //await createColl(database , collName); let collObj = await connectColl(database, collName); // mongodb默认_id为主键，不设置的话会自动帮你加上 let obj = { _id: &quot;001&quot;, name: &quot;张三&quot;, sex: &quot;Female&quot; }; await insert(collObj, obj); let arr = [ { _id: &quot;002&quot;, name: &quot;王五&quot;, sex: &quot;Female&quot; }, { _id: &quot;003&quot;, name: &quot;李四&quot;, sex: &quot;Male&quot; } ]; await insertM(collObj, arr); // 为空对象时相当于MySQL中的select * from XXX let result = await findData(collObj, {}); console.log(result); let query = { name: '李四' }; result = await findData(collObj, query); console.log(result); } finally { // 关闭连接 await client.close(); } } // 这个catch是Promise对象的一个方法，用于捕捉错误，也就相当于try/catch // console.dir()可以显示一个对象所有的属性和方法。 run().catch(console.dir); ","link":"https://solitudealma.github.io/post/pb6nCDUaa/"},{"title":"题解Project Euler3.Largest prime factor","content":"引用 可以看看这位大佬的证明，个人感觉挺详细的，但是没看明白hhh。自始至终对数学都慢半拍 haust_fx 1.试除法判定质数 2.分解质因数 质数 题目描述 This problem is a programming version of Problem 3 from projecteuler.net The prime factors of 13195 are 5,7,13 and 29. What is the largest prime factor of a given number N ? 样例 Input Format First line contains T, the number of test cases. This is followed by T lines each containing an integer N. Output Format For each test case, display the largest prime factor of N. Constraints 1≤1 \\leq1≤ T ≤10\\leq 10≤10 10≤10 \\leq10≤ N ≤1012\\leq 10^{12}≤1012 Sample Input 0 2 10 17 Sample Output 0 5 17 Explanation 0 Prime factors of 10 are {2,5}, largest is 5. Prime factor of 17 is 17 itself, hence largest is 17. 算法 (数论) O(1)O(1)O(1) 对于试除法分解质因数的证明我就不解释了，我也不是很明白2333。感兴趣的可以看看这个1.试除法判定质数 2.分解质因数 质数。这位大佬有给出具体证明，还是挺详细的。 要找到质因数首先我们得先找到因数，然后看看这个因数是不是质数，再和上一个质因数比较或者存入数组中。这是我想到的朴素做法。 但是试除法分解质因数不需要这么做，他能快速找出所有质因子。 时间复杂度 O(n)O(\\sqrt{n})O(n​) C++ 代码 #include &lt;iostream&gt; using namespace std; typedef long long LL; int n; int main() { cin &gt;&gt; n; while (n --) { LL t , res = 0; cin &gt;&gt; t; // 一个数的因子是成对存在的，那么比较小的那一个必定不会超过根号n for(LL i = 2; i &lt;= t / i; i ++) { if(t % i == 0) { while(t % i == 0) t /= i; // 每一次的质因子都比前一个大，所以直接更新 res = i; } } // 因为可能刚好这个数本来就是质数，那么它的最大质因子就是他自己，如果这个数有因子的话，最后必定会为1 if(t &gt; 1) res = max(res , t) , cout &lt;&lt; res &lt;&lt; endl; else cout &lt;&lt; res &lt;&lt; endl; } return 0; } ","link":"https://solitudealma.github.io/post/ProjectEuler3/"},{"title":"题解ProjectEuler2.Even Fibonacci numbers","content":"引用 虽然知道这是一道数论题，但优先想到的还是怎么递推或者递归求解。看到评论区大佬的题解后发现还能这么玩？？？ 关于为什么可以这么玩，可以看看第二个大佬的题解 Mehul Singh Rathore 找到大佬的评论就能看到 自来也sama 欧垃计划Level-1解题总结 题目描述 This problem is a programming version of Problem 2 from projecteuler.net Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1,2,3,5,8,13,21,34,55,89 By considering the terms in the Fibonacci sequence whose values do not exceed N, find the sum of the even-valued terms. 样例 Input Format First line contains T that denotes the number of test cases. This is followed by T lines, each containing an integer, N. Output Format Print the required answer for each test case. Constraints 1≤1 \\leq1≤ T ≤105\\leq 10^5≤105 10≤10 \\leq10≤ N ≤4×1016\\leq 4 \\times 10^{16}≤4×1016 Sample Input 0 2 10 100 Sample Output 0 10 44 Explanation 0 For N =10, we have {2,8}, sum is 10. For N =100, we have {2,8,34}, sum is 44. 算法 (数论) O(1)O(1)O(1) 从数据范围上看可能会TLE，但实际上计算斐波那契数列值最接近 4×10164 \\times 10^{16}4×1016并不需要多久，所以对于这个我们可以直接暴力去算。 但好歹他也是个数论题，你这样暴力就有点说不过去了，既然涉及数学知识那么就应该用数学知识来解决。 从题目我们可以发现每三个数就会出现一次偶数。而斐波那契数列又具有f(n) = f(n - 1) + f(n - 2)的性质，那么我们可以往这方面想，因为一个序列如果满足一种性质，那么满足一定规律的子序列同样也会满足相似的性质。比如等差数列，我们从第一个开始，每三个取一个数，构成的新数列同样也满足等差数列的性质。 我们仔细看看 0 2 8这三个数，发现第三个数是前一个数的四倍加上前二个数，即E(n) = 4 ×\\times× E(n - 1) + E(n - 2)。那么我们只需要计算一下这样的新斐波那契数列中小于N的前n项的和就行了 时间复杂度 O(1)O(1)O(1) 直接套公式 C++ 代码 #include &lt;iostream&gt; using namespace std; typedef long long LL; int n; int main() { cin &gt;&gt; n; // 常规递推 // while (n --) // { // LL t , res = 0 , a = 1 , b = 1 , c; // cin &gt;&gt; t; // for(int i = 1; ; i ++) // { // c = a + b; // a = b; // b = c; // if(c &lt; t &amp;&amp; !(c &amp; 1)) res += c; // if(c &gt; t) break; // } // cout &lt;&lt; res &lt;&lt; endl; // } // 构建新的斐波那契数列 while (n --) { LL t , res = 2 , a = 0 , b = 2 , c; cin &gt;&gt; t; for(int i = 1; ; i ++) { c = a + 4 * b; a = b; b = c; if(c &lt; t) res += c; if(c &gt; t) break; } cout &lt;&lt; res &lt;&lt; endl; } return 0; } ","link":"https://solitudealma.github.io/post/ProjectEuler2/"},{"title":"题解ProjectEuler1.Multiples of 3 and 5","content":"引用 刚开始只想到了暴力做法，怎么优化都不能过，后来在群友的提示下想到了数列前n项和。下面这位大佬的题解相当于优化了前n项和的做法吧 Anish Acharya 找到大佬的评论就能看到 题目描述 This problem is a programming version of Problem 1 from projecteuler.net If we list all the natural numbers below 10 that are multiples of 3 or 5 , we get 3 , 5 , 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below N. 样例 Input Format First line contains T that denotes the number of test cases. This is followed by T lines, each containing an integer, N. Output Format For each test case, print an integer that denotes the sum of all the multiples of 3 or 5 below N. Constraints 1≤1 \\leq1≤ T ≤105\\leq 10^5≤105 1≤1 \\leq1≤ N ≤109\\leq 10^9≤109 Sample Input 0 2 10 100 Sample Output 0 23 2318 Explanation 0 For N = 10, if we list all the natural numbers below 10 that are multiples of 3 or 5 , we get 3 , 5 , 6 and 9. The sum of these multiples is 23. Similarly for N =100, we get 2318. 算法 (数论) O(1)O(1)O(1) 从数据范围我们可以发现要是想拿满分朴素做法是不行的，所以我们可以从其他方面入手。因为这是一道数论题，我们应该数学方面的知识入手。细心的你应该发现了3的倍数其实是一个等差数列，5的倍数也是。那么我们就可以直接套公式求和就可以了。但是需要注意的是3和5是有公倍数的，所以我们在计算的时候会重复计算，因此我们还要求一下差项为15的等差数列的前n项和。 还有一个需要注意的是，因为题目求的是小于N的和，所以如果3|N、5|N 或者15|N成立的话就需要减去N O(1) Solution : say N= 100 so, max multiple of 3 here below N is 99 i.e. 3*33 so, sum of all multiples of 3 has a pattern 3(1+2+3+....+33) use this 这个做法和前n项和一致，只不过稍微转换了一下思路，我们先求出3的倍数中小于N的有几个，然后对1-几个求和再乘以3就是小于N中3的倍数和 时间复杂度 O(1)O(1)O(1) 直接套公式 C++ 代码 #include &lt;iostream&gt; using namespace std; int n; int main() { cin &gt;&gt; n; long long res = 0; // 朴素做法，但是会超时，只能拿60分 // while (n --) // { // long long t; // res = 0; // cin &gt;&gt; t; // for(long long i = 1; i &lt;= t / 3; i ++) // { // if(i * 3 &gt;= t) continue; // res += i * 3; // if(i * 5 &gt;= t || (i * 5) % 15 == 0) continue; // res += i * 5; // } // cout &lt;&lt; res &lt;&lt; endl; // } // 等差数列前n项和 // while (n --) // { // long long t , sum_mul_3, sum_mul_5 , sum_mul_15; // res = 0; // cin &gt;&gt; t; // // 小于t的最大的3的倍数即为 3*(t/3) (t/3)是向下取整 // sum_mul_3 = (t / 3) * (3 + 3 * (t / 3)) / 2; // if(t % 3 == 0) sum_mul_3 -= 3 * (t / 3); // sum_mul_5 = (t / 5) * (5 + 5 * (t / 5)) / 2; // if(t % 5 == 0) sum_mul_5 -= 5 * (t / 5); // sum_mul_15 = (t / 15) * (15 + 15 * (t / 15)) / 2; // if(t % 15 == 0) sum_mul_15 -= 15 * (t / 15); // res = sum_mul_3 + sum_mul_5 - sum_mul_15; // cout &lt;&lt; res &lt;&lt; endl; // } // 算是前n项和的优化吧，毕竟不需要判断了 while (n --) { long long t , three , five , fifteen , res = 0; cin &gt;&gt; t; // 求小于N的3的倍数的个数 three = (t - 1) / 3; five = (t - 1) / 5; fifteen = (t - 1) / 15; res = 3 * (three * (three + 1) / 2) + 5 * (five * (five + 1) / 2) - 15 * (fifteen * (fifteen + 1) / 2); cout &lt;&lt; res &lt;&lt;endl; } return 0; } ","link":"https://solitudealma.github.io/post/ProjectEuler1/"},{"title":"题解“九韶杯”河科院程序设计协会第一届程序设计竞赛G.最强对手矩阵","content":"引用 官方C++题解 官方Java题解 题目描述 这一天你来到了蓝桥杯的考场，你发现考场是一个N*M的矩阵。 因为你的群友很多，你知道考场内每个人有多强，并且把实力换算成了数值。(因为有的人太弱了,所以可能出现实力值是负数的可能) 你想知道考场内实力总和最大的矩阵区域的实力和是多少。 （注意:区域是按照矩形划分的） 样例 输入格式 第一行两个整数 N M (1≤N×M≤2e5)\\left(1\\leq N \\times M \\leq 2e5\\right)(1≤N×M≤2e5) 第二到N+1行是一个N*M的矩阵代表考场内的情况 (−200&lt;=实力值&lt;=200)\\left( -200&lt;=实力值&lt;=200 \\right)(−200&lt;=实力值&lt;=200) 输出格式 请输出考场内实力总和最大的矩阵区域的实力和是多少 输入样例 1： 3 2 8 9 10 11 -4 11 输出样例 1： 45 输入样例 2： 3 2 8 9 10 11 -12 5 输出样例 2： 38 备注 对于10%数据 (1≤N≤M≤10)\\left(1\\leq N \\leq M \\leq 10\\right)(1≤N≤M≤10) 对于40%数据 (1≤N≤M≤100)\\left(1\\leq N \\leq M \\leq 100\\right)(1≤N≤M≤100) 对于70%数据 (1≤N≤M≤400)\\left(1\\leq N \\leq M \\leq 400\\right)(1≤N≤M≤400) 对于100%数据 (1≤N×M≤2e5)\\left(1\\leq N \\times M \\leq 2e5\\right)(1≤N×M≤2e5) 算法 (二位前缀和) O(nm)O(nm)O(nm) 从数据范围我们可以发现要是想拿满分朴素做法是不行的，即遍历所有子矩阵。这样的话时间复杂度是 O(n2m2)O(n^2m^2)O(n2m2) , 铁定超时。还有不要直接开全局二维数组，这样会爆段错误，具体原因暂时不清楚。我们只需要根据输入的n，m来决定数组大小就行了。 对于新的做法可以看看这个题解AcWing126.最大的和，其实就是换了一种预处理前缀和的方法，通常我们都是算这个点左上角的数的和，但是现在我们只需要算每一列的和就行了，然后枚举的时候也不需要枚举左上角的点和右下角的点，只需要枚举上下界或者左右界，再枚举每一列或者每一行即可。这题也同样可以用贪心思想 因为数据范围的问题我们可以考虑翻转数组，如果行大于列，那么我们就翻转数组，这样我们遍历的行就会变少了，大大减少了复杂度，因为上下界循环次数是n!，虽然列的遍历也增多了，但是相对而言是影响不大的 时间复杂度 O(n)O(n)O(n) 预处理前缀和数组，所以计算的时候是 O(1)O(1)O(1) 的 C++ 代码 #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; typedef long long LL; int main() { int n , m; LL ans = -0x3f3f3f3f; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int a[n + 1][m + 1]; for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) scanf(&quot;%d&quot;, &amp;a[i][j]); if(n &gt; m) { int b[m + 1][n + 1]; // 复制数据 for (int i = 1; i &lt;= m; i ++ ) for (int j = 1; j &lt;= n; j ++ ) b[i][j] = a[j][i]; // 交换行列 swap(n , m); // 预处理前缀和 for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j++) b[i][j] += b[i - 1][j]; // 枚举上下界 for(int i = 1; i &lt;= n; i ++) { for(int j = i; j &lt;= n; j ++) { LL res = 0; for(int k = 1; k &lt;= m; k ++) { // 计算前k列的值，小于零就舍弃，大于就看看与ans谁大 res += b[j][k] - b[i - 1][k]; if(res &lt; 0) res = 0; if(res &gt; ans) ans = res; // res = max(res , 0LL) + b[j][k] - b[i - 1][k]; // ans = max(res , ans); } } } } else { // 预处理前缀和 for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) a[i][j] += a[i - 1][j]; // 枚举上下界 for(int i = 1; i &lt;= n; i ++) { for(int j = i; j &lt;= n; j ++) { LL res = 0; for(int k = 1; k &lt;= m; k ++) { // 计算前k列的值，小于零就舍弃，大于就看看与ans谁大 res += a[j][k] - a[i-1][k]; if(res &lt; 0) res = 0; if(res &gt; ans) ans = res; //res = max(res , 0LL) + a[j][k]-a[i-1][k]; //ans = max(ans , res); } } } } printf(&quot;%lld\\n&quot; , ans); return 0; } ","link":"https://solitudealma.github.io/post/NiuKeHeKeYuanJiuShaoBei2021G/"},{"title":"20210425 [日记]","content":"终于熬完了蓝桥杯和天梯赛，只能说还是太菜了，虽然寒假就开始准备了，但还是顶不住啊呜呜呜。蓝桥杯估计只有省四了，天梯赛团体个人都没有奖。刚开始学算法只是为了应付这两个比赛，但是经历了这几个月的学习，发现算法的学习还是挺好玩的，见识过大佬的实力之后，发现自己前进的空间还是很大的hhh。只能说继续努力吧2333 ","link":"https://solitudealma.github.io/post/20200425/"},{"title":"题解AcWing126. 最大的和","content":"引用 贪心思想可以看看秦同学的题解，大佬还是一如既往的厉害，我还是依然很菜。在这里就不画图了，可以看看以下大佬画的图 秦淮岸灯火阑珊 AcWing 126. 最大的和 Bug-Free AcWing 126. 最大的和 Aniway AcWing 126. 最大的和 皮皮柯 AcWing 126. 最大的和(连续子序列和dp求解） 题目描述 给定一个包含整数的二维矩阵，子矩形是位于整个阵列内的任何大小为 1×1 或更大的连续子阵列。 矩形的总和是该矩形中所有元素的总和。 在这个问题中，具有最大和的子矩形被称为最大子矩形。 例如，下列数组： 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 其最大子矩形为： 9 2 -4 1 -1 8 它拥有最大和 15。 样例 输入格式 输入中将包含一个 N×N 的整数数组。 第一行只输入一个整数 N，表示方形二维数组的大小。 从第二行开始，输入由空格和换行符隔开的 N2 个整数，它们即为二维数组中的 N2 个元素，输入顺序从二维数组的第一行开始向下逐行输入，同一行数据从左向右逐个输入。 数组中的数字会保持在 [−127,127] 的范围内。 输出格式 输出一个整数，代表最大子矩形的总和。 数据范围 1≤N≤1001≤N≤1001≤N≤100 输入样例 1： 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 输出样例 1： 15 算法 (二位前缀和) O(n)O(n)O(n) 这题的数据范围很小，所以我们直接遍历所有子矩阵就行了，但是这样做复杂度是很高的，虽然不会超时，但是在这里介绍一个更好的思路。可以减少一层循环。我们预处理前缀和的时候，只计算列方向的前缀和或者行方向的前缀和。这样遍历的时候我们只要遍历上下界，即矩阵的上下边或者左右边就行了，然后算一下前k列或前k行的最大值。 这题也有一点点贪心的影子，如果前几列加上这一列比零还小，那么我们就直接舍去，因为这个子矩阵的话，我们还不如选剩下的矩阵，因为加上这个矩阵只会更小 多说不益，我们来试试吧 时间复杂度 O(n2m)O(n^2m)O(n2m) 预处理前缀和数组，所以计算的时候是 O(1)O(1)O(1) 的 C++ 代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; int a[N][N]; int n; int maxx = -0x3f3f3f3f; int main() { cin &gt;&gt; n; // 读入数据 for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= n; j ++) cin &gt;&gt; a[i][j]; // 预处理前缀和 for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= n; j ++) a[i][j] += a[i - 1][j]; // 遍历上下界 for(int i = 1; i &lt;= n; i ++) { for(int j = i; j &lt;= n; j ++) { // 存每一个上下界的前k列的值 int t = 0; for(int k = 1; k &lt;= n; k ++) { // 计算前k列，如果上一个t小于零就不要了 t = max(t , 0) + a[j][k] - a[i - 1][k]; maxx = max(maxx , t); } } } cout &lt;&lt; maxx &lt;&lt; endl; return 0; } ","link":"https://solitudealma.github.io/post/AcWing126/"},{"title":"题解2020届天梯赛总决赛L2-4网红点打卡攻略","content":"引用 这题并不是一定要dfs，也可以直接用邻接矩阵判断，但是因为想熟悉一下dfs，所以采用了邻接表这个方法，邻接矩阵的可以参考一下这位大佬的代码 东篱下の悠然 2020年11月28日天梯赛GPLT总决赛（全部题目 + 189分代码答案） 题目描述 一个旅游景点，如果被带火了的话，就被称为“网红点”。大家来网红点游玩，俗称“打卡”。在各个网红点打卡的快（省）乐（钱）方法称为“攻略”。你的任务就是从一大堆攻略中，找出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略。 样例 输入格式 首先第一行给出两个正整数：网红点的个数 N(1&lt;N≤200)N(1&lt;N≤200)N(1&lt;N≤200) 和网红点之间通路的条数 $ M $ 。随后 $ M $ 行，每行给出有通路的两个网红点、以及这条路上的旅行花费（为正整数），格式为“网红点1 网红点2 费用”，其中网红点从 $ 1 $ 到 $ N $ 编号；同时也给出你家到某些网红点的花费，格式相同，其中你家的编号固定为 0 。 再下一行给出一个正整数 K，是待检验的攻略的数量。随后 K 行，每行给出一条待检攻略，格式为： nV1V2⋯Vnn V_1V_2 ⋯ V_nnV1​V2​⋯Vn​ ​​ 其中 $ n(≤200) $ 是攻略中的网红点数，ViV_iVi​ 是路径上的网红点编号。这里假设你从家里出发，从 V​1V_​1V​​1 开始打卡，最后从 V​nV_​nV​​n回家。 输出格式 在第一行输出满足要求的攻略的个数。 在第二行中，首先输出那个能在每个网红点打卡仅一次、并且路上花费最少的攻略的序号（从 1 开始），然后输出这个攻略的总路费，其间以一个空格分隔。如果这样的攻略不唯一，则输出序号最小的那个。 题目保证至少存在一个有效攻略，并且总路费不超过 10910^9109 。 输入样例 6 13 0 5 2 6 2 2 6 0 1 3 4 2 1 5 2 2 5 1 3 1 1 4 1 2 1 6 1 6 3 2 1 2 1 4 5 3 2 0 2 7 6 5 1 4 3 6 2 6 5 2 1 6 3 4 8 6 2 1 6 3 4 5 2 3 2 1 5 6 6 1 3 4 5 2 7 6 2 1 3 4 5 2 6 5 2 1 4 3 6 输出样例 3 5 11 样例说明： 第 2、3、4、6 条都不满足攻略的基本要求，即不能做到从家里出发，在每个网红点打卡仅一次，且能回到家里。所以满足条件的攻略有 3 条。 第 1 条攻略的总路费是：(0-&gt;5) 2 + (5-&gt;1) 2 + (1-&gt;4) 2 + (4-&gt;3) 2 + (3-&gt;6) 2 + (6-&gt;2) 2 + (2-&gt;0) 2 = 14； 第 5 条攻略的总路费同理可算得：1 + 1 + 1 + 2 + 3 + 1 + 2 = 11，是一条更省钱的攻略； 第 7 条攻略的总路费同理可算得：2 + 1 + 1 + 2 + 2 + 2 + 1 = 11，与第 5 条花费相同，但序号较大，所以不输出。 算法 (记忆化搜索) O(n2)O(n^2)O(n2) 这个样例解释有点小坑，反正我是没看出来。它指的每个点不是攻略给出的点，而是1~n个点2333。由题目的意思我们可以知道，只需要dfs搜一下每一个攻略，看看是不是能到终点，并且遍历了n个点，然后记录一下费用和攻略个数即可。 时间复杂度 O(n)O(n)O(n) 鸽了 C++ 代码 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; const int N = 210 , M = 100010; int n , m , k , sum , f; int INF = 0x3f3f3f3f; int h[N] , e[N * N] , ne[N * N] , idx; int path[M] , g[N][N]; long long res[M]; bool st[N]; void add(int a , int b) { e[idx] = b , ne[idx] = h[a] , h[a] = idx ++; } int dfs(int u , int idx) { //虽然总费用不超过10的9次方，但是int也才2开头的九位数，所以用LL long long sum = 0; //表示这个点已经被遍历过了 st[u] = true; if(u == 0) { //标记这个攻略能回到起点 f = 1; return sum; } //如果当前的点为-1表示不能往下走所以直接返回0； if(h[u] == -1) return 0; for(int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if(!st[j]) { //如果这个点没有被遍历过，并且是路线的下一个点，那么就继续走 if(path[idx] == j) sum += g[u][j] + dfs(j , idx + 1); } } // 返回以u为起点的费用 return sum; } int main() { long long minx = INF; cin &gt;&gt; n &gt;&gt; m; //初始化头结点和攻略路径 memset(h , -1 ,sizeof h); memset(path , -1 , sizeof path); for(int i = 0; i &lt; m; i ++) { int a , b , c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; //因为这题是无向有环图，所以要加两条边，然后用g记录费用，也就是邻接矩阵 add(a , b); add(b , a); g[a][b] = g[b][a] = c; } cin &gt;&gt; k; int cnt = 0; for(int i = 0; i &lt; k; i ++) { int t , flag = 0; cin &gt;&gt; t; for(int j = 0; j &lt; t; j ++) cin &gt;&gt; path[j]; //将起点加入路径，作为终点 path[t] = 0; //如果这个点的起点不是零能到的点，那么后续就不需要继续了 for(int j = h[0]; j != -1; j = ne[j]) if(e[j] == path[0]) flag = 1; if(flag) { int t1 = 0; //dfs时从攻略的起点开始会好一点 res[i] += dfs(path[0] , 1) + g[0][path[0]]; //看一下是否n个点都有且只到过一次 for(int i = 0; i &lt;= n; i ++) if(st[i]) t1++; //如果到了起点并且是n个点都遍历了，那么就更新minx，并且cnt++，n+1是因为包括了0这个点，不这么写也可以 if(f &amp;&amp; t1 == n + 1) minx = min(res[i] , minx) , cnt ++; f = 0; } memset(path , -1 , sizeof path); memset(st , 0 , sizeof st); } cout &lt;&lt; cnt &lt;&lt; endl; //遍历数组看看最先等于minx是哪一个 for(int i = 0; i &lt; k; i ++) { if(res[i] == minx) { cout &lt;&lt; i + 1 &lt;&lt; ' ' &lt;&lt; res[i] &lt;&lt; endl; break; } } return 0; } ","link":"https://solitudealma.github.io/post/2020TianTiL2-4/"},{"title":"题解2020届天梯赛总决赛L3-1那就别担心了","content":"引用 刚开始想到了怎么做，但是想不明白该怎么判断是否有些点不能达到终点，在群里问了一些大佬还是不能理解，看了大佬的题解之后，再结合群里的大佬所说的，瞬间就理解了，嘤嘤嘤 巴扎嘿呀 L3-1 那就别担心了（记忆化搜索） 题目描述 下图转自“英式没品笑话百科”的新浪微博 —— 所以无论有没有遇到难题，其实都不用担心。 博主将这种逻辑推演称为“逻辑自洽”，即从某个命题出发的所有推理路径都会将结论引导到同一个最终命题（开玩笑的，千万别以为这是真正的逻辑自洽的定义……）。现给定一个更为复杂的逻辑推理图，本题就请你检查从一个给定命题到另一个命题的推理是否是“逻辑自洽”的，以及存在多少种不同的推理路径。例如上图，从“你遇到难题了吗？”到“那就别担心了”就是一种“逻辑自洽”的推理，一共有 3 条不同的推理路径。 样例 输入格式 输入首先在一行中给出两个正整数 N（1&lt;N≤500）N（1&lt;N≤500）N（1&lt;N≤500） 和 M，分别为命题个数和推理个数。这里我们假设命题从 1 到 N 编号。 接下来 M 行，每行给出一对命题之间的推理关系，即两个命题的编号 S1 S2，表示可以从 S1 推出 S2。题目保证任意两命题之间只存在最多一种推理关系，且任一命题不能循环自证（即从该命题出发推出该命题自己）。 最后一行给出待检验的两个命题的编号 A B。 输出格式 在一行中首先输出从 A 到 B 有多少种不同的推理路径，然后输出 Yes 如果推理是“逻辑自洽”的，或 No 如果不是。 题目保证输出数据不超过 10910^9109 输入样例 1： 7 8 7 6 7 4 6 5 4 1 5 2 5 3 2 1 3 1 7 1 输出样例 1： 3 Yes 输入样例 2： 7 8 7 6 7 4 6 5 4 1 5 2 5 3 6 1 3 1 7 1 输出样例 2： 3 No 算法 (记忆化搜索) O(n2)O(n^2)O(n2) 个人感觉这是一个很简单的图论题。由题目的意思我们可以知道，只需要存下所有命题能推导什么命题就行了。相信聪明的你已经想到了，那就是邻接表。至于邻接表呢就是一个用于存储图的结构，相信邻接矩阵大家都熟悉吧，就是用一个二维矩阵存储某个点是否能到另一个点的信息比如第一行第二列的数不为0，就表示1这个点能到2这个点，如果带权值那么数组的值就是权值。但是邻接矩阵一般不用来存无向图，因为你不能存两条边的信息，而且也浪费空间。所以对于图的存储我们可以用邻接表。其实邻接表就是一条单链表上的每一个节点都是一条单链表，上面存储了这个头结点能到那个点上，存储顺序无关紧要。 这道题其实是有向无环图的遍历，我们先把每个点能到的点连一条边（如果是无环图就反向连一条就行），即在头结点上用头插法把节点插入就行了。因为按照题目的意思我们不仅要找到起点延申出来的点有几条能到终点，还有判断是否都能到终点。所以对于这种遍历我们可以采用dfs，一条路走到底，但是因为数据范围比较大，能多点可能会交错，如果只是单纯的遍历是不能在规定时间内跑完的，所以我们应该存下已经遍历的点到达终点的路径数，这样在第二次遍历这个点的时候就不用再次遍历了，也就是记忆化搜索。 时间复杂度 O(n)O(n)O(n) 所有点都只搜一次，嗯，应该是这样的 C++ 代码 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; const int N = 1000; //h用于存储头结点，初始化为-1 e为数据域，存储能到的点 ne为指针域 idx表示当前用到的是第几个节点 int h[N] , e[N * N] , ne[N * N] , idx; int num[N]; //将两点之间连一条边，头插法 void add(int a , int b) { e[idx] = b , ne[idx] = h[a] , h[a] = idx ++; } int n , m , x , y , flag; int dfs(int u) { int res = 0; //如果这个点搜过了就直接返回以它为起点的路径数 if(num[u] != -1) return num[u]; //如果搜到了终点，那么这个点的值为1，即以它为起点的路径只有一条 if(u == y) return num[u] = 1; //如果这个为NULL,那么表示以这个点为起点的路径为0，并且它不能到达终点 if(h[u] == -1) { flag = 1; return num[u] = 0; } //遍历每条链表上的点 for(int i = h[u]; i != -1; i = ne[i]) { //因为是有向无环图，所以不需要记录这个点是不是被遍历过 int j = e[i]; res += dfs(j); } //遍历完返回结果 return num[u] = res; } int main() { memset(h, -1, sizeof h); memset(num , -1 , sizeof num); cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i ++) { int a , b; cin &gt;&gt; a &gt;&gt; b; add(a, b); } cin &gt;&gt; x &gt;&gt; y; int res = dfs(x); cout &lt;&lt; res &lt;&lt; ' '; //如果为真代表有至少一个点不能到达终点 if(flag || !res) cout &lt;&lt; &quot;No&quot;; else cout &lt;&lt; &quot;Yes&quot;; return 0; } ","link":"https://solitudealma.github.io/post/2020TianTiL3-1/"},{"title":"题解洛谷P1255.数楼梯","content":"题目描述 楼梯有N阶，上楼可以一步上一阶，也可以一步上二阶。 编一个程序，计算共有多少种不同的走法。 样例 输入格式 一个数字，楼梯数。 输出格式 输出走的方式总数。 输入输出样例 输入 #1复制 4 输出 #1复制 5 说明/提示 对于 60%60\\%60% 的数据，N≤50N \\leq 50N≤50； 对于 100%100\\%100% 的数据，N≤5000N \\leq 5000N≤5000。 算法1 (递推 + 高精度) 用unsigned long long 很明显已经存不下了，所以我们应该用高精度来解决。妈的，头脑有点混乱，debug了好久，后来写完了发现又wa了，结果是没考虑0，而且我的特判和else一起输出了2333。总的来说这题挺简单的。高精度就完了。 时间复杂度 不会算，也不想算 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int n; vector&lt;int&gt; A(1 , 1) , B(1 , 2) , C; vector&lt;int&gt; add(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if (A.size() &lt; B.size()) return add(B, A); vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size(); i ++ ) { t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } int main() { cin &gt;&gt; n; if(n == 0) cout &lt;&lt; 0; else if(n == 1) cout &lt;&lt; 1; else if( n == 2) cout &lt;&lt; 2; else { for (int i = 3; i &lt;= n; i ++ ) { C = add(A , B); A.swap(B);//交换容器元素，也可以试试copy这个函数 B.swap(C); } for(int i = B.size() - 1; i &gt;= 0 ; i --) cout &lt;&lt; B[i]; } return 0; } ","link":"https://solitudealma.github.io/post/LuoGuP1255/"},{"title":"题解第十一届蓝桥杯E.七段码","content":"引用 看了大佬的题解深受启发 尘民 第十一届蓝桥杯 ——七段码 B1ackGod 蓝桥杯填空题总结(未完待续... 题目描述 小蓝要用七段码数码管来表示一种特殊的文字。 上图给出了七段码数码管的一个图示，数码管中一共有 7 段可以发光的二极管，分别标记为 a, b, c, d, e, f, g。 小蓝要选择一部分二极管（至少要有一个）发光来表达字符。在设计字符的表达时，要求所有发光的二极管是连成一片的。 例如：b 发光，其他二极管不发光可以用来表达一种字符。 例如：c 发光，其他二极管不发光可以用来表达一种字符。 这种方案与上一行的方案可以用来表示不同的字符，尽管看上去比较相似。 例如：a, b, c, d, e 发光，f, g 不发光可以用来表达一种字符。 例如：b, f 发光，其他二极管不发光则不能用来表达一种字符，因为发光的二极管没有连成一片。 请问，小蓝可以用七段码数码管表达多少种不同的字符？ 答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。 本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 样例 无样例 算法 (并查集) O(n)O(n)O(n) 用 1 ~ 7 来代表 a ~ g； 若某两个二极管相邻，那么就在它们之间连一条边； 先用 dfs 枚举出二极管的所有亮灭情况； 再用 并查集 判断是否只有一个连通块； 首先我们用二维数组存相邻的两段，接着利用指数型枚举，求出所有的组合，然后利用并查集判断组合中的段是否连通并且只存在一个连通块即可 时间复杂度 O(n)O(n)O(n) 优化 平均时间复杂度 最坏时间复杂度 无优化 O(logn)O(logn)O(logn) O(n)O(n)O(n) 路径压缩 O(α(n))O(\\alpha(n))O(α(n)) O(logn)O(logn)O(logn) 按秩合并 O(logn)O(logn)O(logn) O(logn)O(logn)O(logn) 路径压缩 + 按秩合并 O(α(n))O(\\alpha(n))O(α(n)) O(α(n))O(\\alpha(n))O(α(n)) C++ 代码 #include &lt;iostream&gt; using namespace std; const int N = 10; int e[N][N] , p[N] , st[N]; int ans; int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } void dfs(int u) { if(u &gt; 7) { //初始化集合 for(int i = 1; i &lt;= 7; i ++) p[i] = i; //判断是否连通，并且这两段都被选了 for(int i = 1; i &lt;= 7; i ++) for(int j = 1; j &lt;= 7; j ++) if(e[i][j] &amp;&amp; st[i] != 2 &amp;&amp; st[j] != 2) p[find(i)] = find(j); int cnt = 0; for(int i = 1; i &lt;= 7; i ++) if(st[i] != 2 &amp;&amp; p[i] == i) cnt ++; //因为我们判断的时候是判断该组合中的段是否选了，并且父节点相同， //而且题意又是只有连成一片才是算一种答案，所以只有在cnt为1的时候，才是我们要的组合，有可能是存在两个或以上的连通块 if(cnt == 1) ans ++; return; } //0 待选 //1 选该段 //2 不选该段 st[u] = 1; dfs(u + 1); st[u] = 2; dfs(u + 1); } int main() { //初始化相邻的段 e[1][2] = e[1][6] = 1; e[2][1] = e[2][7] = e[2][3] = 1; e[3][2] = e[3][7] = e[3][4] = 1; e[4][3] = e[4][5] = 1; e[5][4] = e[5][7] = e[5][6] = 1; e[6][1] = e[6][7] = e[6][5] = 1; e[7][2] = e[7][3] = e[7][5] = e[7][6] = 1; dfs(1); cout &lt;&lt; ans &lt;&lt; endl; return 0; } ","link":"https://solitudealma.github.io/post/LanQiao11E/"},{"title":"并查集的介绍以及模板的分享","content":"今天我们来介绍一下并查集 那么什么是并查集呢 我们来看看百度百科是怎么介绍的，emmm，好像不太能理解。其实就是一个个不相交的集合之间的合并与查询等相关问题的解决方法，这些集合可以想象成一颗颗树。 初始的时候集合里只有一个元素，通过不断地合并形成一个拥有很多元素的集合，比如一个家族中有非常多成员，但是和你有血缘关系的人也就那些，他们之间可以构成一个集合也就是一颗树，树的根节点就是这群人中辈分最大的那一个人，然后一直往下排。如果我们想要判断两个人是否是亲戚关系，那么我们就要判断他们的根节点是不是一样的，也就是查询操作。有时候我们需要合并两个集合，如果只是简单的寻找一个树的根节点，然后让另一颗树变成它的子树的话，在数据非常大的时候效率会非常低，然后现在有两个方法可以解决这一个问题，分别是路径压缩和按秩合并。这里我们只介绍路径压缩方法 首先我们来看看查找函数怎么实现 先将树的根节点初始化 // p数组存每棵树的根节点 int p[MAXN]; void init(int n) { for (int i = 1; i &lt;= n; ++i) p[i] = i; } 接着我们写一下查询函数 //正常的查询 int find(int x) { if(fa[x] == x) return x; else return find(fa[x]); } //结合路径压缩的查询 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } 最后就是合并了(路径压缩) //因为查询的时候就已经实现了路径压缩，所以这里就直接查询并合并即可 void merge(int i, int j) { p[find(i)] = find(j); } 现在我们来讲一下路径压缩是怎么实现的 一般来说我们都是一层一层的往上找，然后找到根节点，那么怎么样才能快速找到根节点呢。其实只要查询的时候当前节点不是根节点，我们就让其指向根节点，这样每一条超根节点的路径上的点都直接指向了根节点，就不需要层层查询了，达到了路径压缩的效果 现在我们来做一道模板题吧 AcWing 836.合并集合 题目描述 一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。 现在要进行 m 个操作，操作共有两种： M a b，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作； Q a b，询问编号为 a 和 b 的两个数是否在同一个集合中； 输入格式 第一行输入整数 n 和 m。 接下来 m 行，每行包含一个操作指令，指令为 M a b 或 Q a b 中的一种。 输出格式 对于每个询问指令 Q a b，都要输出一个结果，如果 a 和 b 在同一集合内，则输出 Yes，否则输出 No。 每个结果占一行。 数据范围 1≤n,m≤1051≤n,m≤1051≤n,m≤105 输入样例： 4 5 M 1 2 M 3 4 Q 1 2 Q 1 3 Q 3 4 输出样例： Yes No Yes C++ #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int N = 100010; int n , m; int p[N]; int find(int x) { if(p[x] != x) p[x] = find(p[x]); return p[x]; } int main () { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++ ) p[i] = i; while (m -- ) { char s[2]; int a , b; scanf(&quot;%s%d%d&quot; , s , &amp;a , &amp;b); if(s[0] == 'M') p[find(a)] = find(b); else { if(find(a) == find(b)) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); } } return 0; } 引用 简单百度了一下，发现其他大佬介绍的很他妈详细，所以在这里提供一下链接避免小伙伴走错房间，hhh Pecco 算法学习笔记(1) : 并查集 lyl194458 并查集 Ocean 傻子都能看懂的并查集入门 ","link":"https://solitudealma.github.io/post/union_find_disjoint_sets/"},{"title":"题解：AcWing 85.不用加减乘除做加法","content":"题目链接 AcWing 85.不用加减乘除做加法 引用 简单看了一下大佬们的题解，真的是操了，一堆骚操作，完全不懂2333，有用low_bit+异或+与实现的，也有和y总一样的异或+与。对比了大佬的题解发现一些细节方面的问题，等会待我一一道来。全加器感兴趣的小伙伴也可以去了解一下，慕明大佬写的题解用到了low_bit算法也可以观摩一下，加深对位运算的理解，对以后做题有意想不到的帮助哦 慕明 AcWing 85. 不用加减乘除做加法 lowbit操作 咲张熊猫人 AcWing 85. 不用加减乘除做加法 Elpsy_3 AcWing 85. 不用加减乘除做加法 C++ 最简单易懂的思路 GRID AcWing 85. 不用加减乘除做加法 全加器，位运算，C++ cornerCao AcWing 85. 不用加减乘除做加法 贺谦 AcWing 85. 不用加减乘除做加法 题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用 ＋、－、×、÷ 四则运算符号。 样例 输入：num1 = 1 , num2 = 2 输出：3 算法 (位运算) O(1)O(1)O(1) 异或 相同为0，不同为1，所以可以起到相加的作用 与 同为1为1，其余为0，起到了进位作用 因为不能使用加减乘除运算，所以我们只能用位运算来实现，因为计算机中的任何运算最终都是位运算来完成的。 那么应该怎么做呢？ 加法一共分成两步，首先按位相加，其次再处理进位。 聪明的小伙伴应该发现了异或运算的结果其实相当于两个二进制数相加，但没有进位，那么如果进位的话怎么办呢，那些大佬已经帮我们解决了这一问题，进位的话只要将这两个数相与然后右移1位就行了，不断迭代，直到进位为0，因为与的结果迟早是0，而右移的结果也迟早是0。这样我们就解决了进位与不进位的处理方式。只要进位为0，那么我们的计算就停止 时间复杂度 O(1)O(1)O(1) 最多计算32次，所以时间复杂度是 O(1)O(1)O(1) 的 C++ 代码 class Solution { public: int add(int num1, int num2){ while (num2) { //可以把num2想象为进位，每次迭代时异或这两个数就是让他们直接相加不进位，然后再处理进位，接着再相加 int sum = num1 ^ num2; int carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum, num2 = carry; } return num1; } }; ","link":"https://solitudealma.github.io/post/AcWing85/"},{"title":"题解：LeetCode 191.位1的个数","content":"题目链接 leetcode 191.位1的个数 引用 做法不唯一，引用一些大佬的解题方法，有助于我们更好的理解位运算的操作，如果需要用到这个数可以用右移k位与1这个方法，其余的没差 我要出去乱说 LeetCode 191. 位1的个数（遍历法、lowbit法） Ncik LeetCode 191. 位1的个数 开水白菜 LeetCode 191. 二进制位1的个数 题目描述 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的示例3中，输入表示有符号整数 -3。 样例 输入样例 00000000000000000000000000001011 输出样例 3 解释 输入的二进制串 00000000000000000000000000001011中，共有三位为 '1'。 输入样例 00000000000000000000000010000000 输出样例 1 解释 输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 输入样例 11111111111111111111111111111101 输出 31 解释 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 算法1 (暴力枚举) O(1)O(1)O(1) 利用右移运算和与运算可以轻松算出32位unsigned int 的二进制表示中的1的个数 时间复杂度 O(1)O(1)O(1) 函数只有一重循环，而且还是常数级别的，所以时间复杂度是 O(1)O(1)O(1) 的 C++ 代码 class Solution { public: int hammingWeight(uint32_t n) { int cnt = 0; for(int i = 0; i &lt; 32; i++) if(n &gt;&gt; i &amp; 1) cnt ++; //或者不需要判断，直接相加即可，与的结果只有0和1，加个判断会稍微慢一点，无伤大雅 return cnt; } }; 算法2 (low_bit) O(1)O(1)O(1) 一个数与上它的负数可以得到它的二进制表示的最后一位1所表示的数，比如8的二进制表示是 0000 0000 0000 0000 0000 0000 0000 1000 ，负数在计算机中以补码的形式存在，所以-8的二进制表示是 1111 1111 1111 1111 1111 1111 1111 1000 ，然后进行与运算得到的是 0000 0000 0000 0000 0000 0000 0000 1000 也就是8，说明8的二进制表示的最后一位1所表示的数是8，所以如果我们用这个方法去计算一个数的二进制表示的1的个数，就可以用一个循环搞定，然后每次循环减去low_bit得到的数，只要这个数不为0就一直循环，比上一个算法快那么一点，因为它最多只循环32次，也就是每一位都有1 时间复杂度 O(1)O(1)O(1) 最多循环32次 C++ 代码 class Solution { public: int low_bit(uint32_t n) { return (n &amp; (~n + 1)); } int hammingWeight(uint32_t n) { int cnt = 0; while(n) n -= low_bit(n) , cnt++; return cnt; } }; ","link":"https://solitudealma.github.io/post/LeetCode191/"},{"title":"题解：AcWing 1236.递增三元组","content":"题目链接 AcWing 1236.递增三元组 引用 z林深时见鹿 AcWing 1236. 递增三元组( 二分解法 ) macat AcWing 1236. 递增三元组 (二分+双指针+前缀和) 冷丁Hacker AcWing 1236. 递增三元组(求赞谢谢兄弟) 田所浩二 AcWing 1236. 递增三元组(模板二分的应用） 小呆呆 AcWing 1236. 递增三元组 题目描述 给定三个整数数组 A=[A1,A2,…AN], B=[B1,B2,…BN], C=[C1,C2,…CN], 请你统计有多少个三元组 (i,j,k) 满足： 1≤i,j,k≤N1≤i,j,k≤N1≤i,j,k≤N Ai&lt;Bj&lt;CkA_i&lt;B_j&lt;C_kAi​&lt;Bj​&lt;Ck​ 样例 输入格式 第一行包含一个整数 N。 第二行包含 N 个整数 A1,A2,…AN。 第三行包含 N 个整数 B1,B2,…BN。 第四行包含 N 个整数 C1,C2,…CN。 输出格式 一个整数表示答案。 数据范围 1≤N≤105,1≤N≤105,1≤N≤105, 0≤Ai,Bi,Ci≤1050≤A_i,B_i,C_i≤1050≤Ai​,Bi​,Ci​≤105 输入样例： 3 1 1 1 2 2 2 3 3 3 输出样例： 27 算法1 (前缀和) O(n)O(n)O(n) 因为我们分别从A，B，C中取出一个数，构成 Ai&lt;Bj&lt;CkA_i &lt; B_j &lt; C_kAi​&lt;Bj​&lt;Ck​ ，如果只是单纯的朴素算法（暴力），那么就是 O(n3)O(n^3)O(n3) 的时间复杂度必定超时。那么能不能找出其中的关系呢 其实细心的你肯定发现了 BjB_jBj​ 作为中间数字和其他两位数的关系，我们只要找出A中有多少了数小于当前的B，C中有多少个数大于B，最后相乘累加即可，相乘是因为排列问题 前缀和：当y总说出可以用前缀和方法做的时候我还在疑惑该怎么做，被他这么一讲，好像对于前缀和又有了新的认识，之前只是停留在对于数组的前缀和计算，但是这题用到的不是数组本身的前缀和，而是数组中的数在这个数组里出现次数的前缀和 怎么理解呢？我们计算A、C中数字出现的次数，然后对他们两个求前缀和，接着只要枚举B，算一下A中小于 BjB_jBj​ 的数的个数和C中大于 CkC_kCk​ 的数的个数的乘积，然后累加就行 时间复杂度 O(n)O(n)O(n) 前缀和的时间复杂度是 O(n)O(n)O(n) C++ 代码 #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int N = 1e5 + 10; int n; int a[N] , b[N] , c[N]; int as[N] , cs[N]; int cnt[N] , s[N]; int main() { scanf(&quot;%d&quot; , &amp;n); //因为数据范围是从零开始，计算前缀和时我们习惯下标从1开始，所以数组中的数都往前移 for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;a[i]) , a[i] ++; for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;b[i]) , b[i] ++; for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;c[i]) , c[i] ++; //计算as[] for(int i = 0; i &lt; n; i ++) cnt[a[i]] ++; for(int i = 1; i &lt; N; i ++) s[i] = s[i - 1] + cnt[i]; //b[i]- 1是因为b增加了1 for(int i = 0; i &lt; n; i ++) as[i] = s[b[i] - 1]; //清空cnt[] 和 s[] memset(cnt , 0 , sizeof cnt); memset(s , 0 , sizeof s); //计算过cs[] for(int i = 0; i &lt; n; i ++) cnt[c[i]] ++; for(int i = 1; i &lt; N; i ++) s[i] = s[i - 1] + cnt[i]; //本来b[i]应该减1，但是因为已经加过了，就不需要了，s[N - 1] - s[b[i]] ==&gt; s[r] - s[l - 1] s[l ~ r] = s[r] - s[l - 1] for(int i = 0; i &lt; n; i ++) cs[i] = s[N - 1] - s[b[i]]; long long res = 0; for(int i = 0; i &lt; n; i ++) res += (long long)as[i] * cs[i]; printf(&quot;%lld&quot; , res); return 0; } 算法2 (sort+二分) O(nlogn)O(nlog_n)O(nlogn​) sort+二分：首先我们先将A、C数组排序，B排不排都无所谓。然后遍历B，二分找出A中小于 BjB_jBj​ 的数的下标，判断一下这个数是不是小于 BjB_jBj​ ，如果不是小于的话就说明A中最小的数都大于它，故小于 BjB_jBj​ 的数为零。同理对于C数组也一样，然后将得到的个数相乘再累加即可 时间复杂度 O(nlogn)O(nlog_n)O(nlogn​) sort+二分的时间复杂度是 O(nlogn)O(nlog_n)O(nlogn​) C++ 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n; int a[N] , b[N] , c[N]; int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;a[i]); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;b[i]); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;c[i]); sort(a , a + n) , sort(c , c + n); long long res = 0; for(int i = 0; i &lt; n; i ++) { int l = 0 , r = n - 1 , mid; long long x , y; while(l &lt; r) { mid = l + r + 1 &gt;&gt; 1; if(a[mid] &lt; b[i]) l = mid; else r = mid - 1; } if(a[l] &lt; b[i]) x = l + 1; else x = 0; l = 0 , r = n - 1; while(l &lt; r) { mid = l + r &gt;&gt; 1; if(c[mid] &gt; b[i]) r = mid; else l = mid + 1; } if(c[l] &gt; b[i]) y = n - l; else y = 0; res += x * y; } printf(&quot;%lld&quot; , res); return 0; } 算法3 (双指针) O(nlogn)O(nlog_n)O(nlogn​) 双指针：首先双指针算法运用的场景必须具备单调性，所以我们同二分一样要先排序，只不过查找的时候用双指针算法，因为查找最多是n次，所以整个算法的时间复杂度是 O(nlogn)O(nlog_n)O(nlogn​)，因为双指针是不回溯的，所以它的时间复杂度才会是 O(n)O(n)O(n)。因此我们计算时应该把三个数组都排序一遍，然后用两个变量计数就行了 时间复杂度 O(nlogn)O(nlog_n)O(nlogn​) 此时整个算法的时间复杂度是 O(nlogn)O(nlog_n)O(nlogn​) ⟺\\Longleftrightarrow⟺ O(n+nlogn)O(n + nlog_n)O(n+nlogn​) C++ 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n; int a[N] , b[N] , c[N]; int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;a[i]); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;b[i]); for(int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot; , &amp;c[i]); sort(a , a + n) , sort(b , b + n) , sort(c , c + n); long long res = 0; //因为指针不能回溯，一旦回溯了时间复杂度就是n三方了，所以将变量定义在循环外 int j = 0 , k = 0; for(int i = 0; i &lt; n; i ++) { //指针停下来时一定在不满足条件的那个数上 while(j &lt; n &amp;&amp; a[j] &lt; b[i]) j ++; //取等号的原因是因为停下来的时候是不满足大于的，第k个数可能小于也可能等于，这样就会导致可能当前多算了一个，因此指针停下来时一定要在满足条件的那个数上，下一次的时候就能继续了 while(k &lt; n &amp;&amp; c[k] &lt;= b[i]) k ++; res += (long long) j * (n - k); } printf(&quot;%lld&quot; , res); return 0; } ","link":"https://solitudealma.github.io/post/AcWing1236/"},{"title":"对于kmp算法的一些理解以及模板的分享","content":"今天我们来讲一下kmp（看毛片）算法 讲到字符串操作有那些算法时，相信学过数据结构的小伙伴们都能想到kmp算法。 那么什么是kmp算法呢？从百度百科我们可以知道，kmp是三个人共同研究出来的一个算法，并以他们的名字命名。它的前身是Brute-Force算法，它有一个很大的缺点，那就是如果当前匹配失败那么指针往前移一位继续匹配。细心的小伙伴很容易就能发现匹配串越长的话本身就不容易匹配成功，那么你每次匹配失败指针只往前移动一位的话，其时间复杂度可想而知。那有没有什么更好的优化方式解决这一问题呢，kmp算法很好地解决了这一问题 初学kmp算法的小伙伴肯定会理解不来这个算法，其实这个算法还是不特别抽象并不是。当时我也是看了两三天才理解其中的奥秘。那废话不多说，我们就来看看这个kmp到底是怎么实现的吧 如果我们要了解kmp算法，那么我们应该先看看Brute-Force算法是怎么实现的，这个算法属于暴力算法。我们来看看具体怎么实现的吧 /* * * s为原串，p为模式串 * */ for(int i = 0; i &lt;= s.size() - p.size(); i ++) { bool flag = true; for(int j = 0; j &lt; p.size(); j ++) { if(p[j] != s[i + j]) { flag = false; break; } } if(flag) printf(&quot;pos : %d&quot; , i); } 从代码中我们可以发现这个算法的时间复杂度是 n∗mn*mn∗m 级别的，算法的实现不唯一，虽然这种写法看上去匹配失败时指针i并没有回退，但是我们要明白，两个字符串对比时，对应的指针是一直在改变的，如果匹配失败，那么指向原串s的指针就要指向本次匹配的第二个位置继续开始新的一次匹配，这样的话时间开销会非常大。 如果我们能够利用Brute-Force算法中的已知信息的话，那么我们是不是可以尝试优化呢，其实kmp算法巧妙地利用了最长前缀与后缀这一重要信息进行优化。 kmp算法的核心其实就是next数组的计算，也就是所谓的《部分匹配表》，里面存着前缀与后缀的最大相等长度。那何为前缀和后缀，前缀就是除第i个字符 p[i] 外的前i个字符组成的字串集合 ，后缀就是除第一个字符 p[1] 外，1-i中的字符组成的字串集合。部分匹配表 next[i] 存的就是i的前缀与后缀的最大公共元素（即最大共有元素的长度）。有了部分匹配表的话，在匹配失败时我们就知道到底需要往前回退多少就能继续往下匹配，而不是回退到本次匹配的下一个位置，这样就大大减少了匹配的时间开销。 那么我们来看看next数组是怎么计算的 // s[]是长文本，p[]是模式串，n是s的长度，m是p的长度，下标从1开始 求模式串的Next数组： for(int i = 2 , j = 0; i &lt;= m; i ++) { while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j ++; ne[i] = j; } 首先我们先手写一下部分匹配表的计算过程 以&quot;ABCDABD&quot;为例： － &quot;A&quot;的前缀和后缀都为空集，共有元素的长度为0； － &quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0； － &quot;ABC&quot;的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0； － &quot;ABCD&quot;的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0； － &quot;ABCDA&quot;的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为&quot;A&quot;，长度为1； － &quot;ABCDAB&quot;的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为&quot;AB&quot;，长度为2； － &quot;ABCDABD&quot;的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 if语句用于计数 next[i] 的值。由上述可以知道，如果 next[i - 1] 不为零，那么下一个位置是否出现新的字符，都可能导致 next[i] 为0（因为后缀一定会带上该字符）。所以我们计算时需要用到前面的匹配值进行回退，也就是while语句，如果当前j不为0并且匹配不相等时，往前退到与 next[j] 的值相等的位置（j回退），如果此时j不为0并且回退后 p[i] 依然不等于 p[j + 1]，那么就继续回退，直到j为0或者p[i] == p[j + 1] 为止。 简单来说就是p串自己与自己匹配，每次尝试 i 与 j+1 位的字符是否匹配，匹配的话 ne[i] 的值就是j的值（每次匹配时会检测j的值以及 p[i] 是否等于 p[j + 1] , 如果这两个条件同时满足，那么就需要回退，回退到当前j的 next[j] 上，如果next[j]不为0，那么是有可能存在前缀与后缀值相等，为0即第i位的next[i] = 0）。 例如：&quot;ABADABAC&quot; － &quot;A&quot;的前缀和后缀都为空集，共有元素的长度为0； － &quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0； － &quot;ABA&quot;的前缀为[A, AB]，后缀为[BA, A]，共有元素为&quot;A&quot;，共有元素的长度1； － &quot;ABAD&quot;的前缀为[A, AB, ABA]，后缀为[BAD, AD, D]，共有元素的长度为0； － &quot;ABADA&quot;的前缀为[A, AB, ABA, ABAD]，后缀为[BADA, ADA, DA, A]，共有元素为&quot;A&quot;，长度为1； － &quot;ABADAB&quot;的前缀为[A, AB, ABA, ABAD, ABADA]，后缀为[BADAB, ADAB, DAB, AB, B]，共有元素为&quot;AB&quot;，长度为2； － &quot;ABADABA&quot;的前缀为[A, AB, ABA, ABAD, ABADA, ABADAB]，后缀为[BADABA, ADABA, DABA, ABA, BA, A]，共有元素为&quot;ABA&quot;，共有元素的长度为3。 － &quot;ABADABAC&quot;的前缀为[A, AB, ABA, ABAD, ABADA, ABADAB, ABADABA]，后缀为[BADABAC, ADABAC, DABAC, ABAC, BAC, AC, C]，共有元素的长度为0。 上面这个例子，匹配最后一个字符的next[i]时，因为出现的字符导致 i 与 j + 1不匹配（此时i为8，j为3，next[j]为3），此时需要回退，回退到哪个位置由next[j]决定，当j为3时，它们依然不相等，所以最后 next[i] = j = 0; 注意 为了方便数组下标从1开始 前缀是指不包括第i的字符的连续字串集合，后缀是指不包括第1个的后i-1的连续字串集合（必需包括区间端点字符） 回退位数 = 已匹配位数 - next[j]， 用本模板的话就是 j = next[j]这行代码 模式串和原串匹配过程与next数组计算类似 既然我们知道了怎么计算next数组，那么就直接看代码吧 for(int i = 2 , j = 0; i &lt;= n; i ++) { while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j];//回退 if(s[i] == p[j + 1]) j ++; //j == m 代表匹配成功 if(j == m) { j = ne[j];//同样也是回退，因为p[j + 1] == '\\0' != s[]的任何一个字符,所以提前让它回退，避免一些边界问题 //匹配成功后的逻辑 } } 接下来我们做一道模板题好好理解一下这万恶的kmp算法吧 AcWing 831.KMP字符串 题目描述 给定一个模式串S，以及一个模板串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。 模板串P在模式串S中多次作为子串出现。 求出模板串P在模式串S中所有出现的位置的起始下标。 输入格式 第一行输入整数N，表示字符串P的长度。 第二行输入字符串P。 第三行输入整数M，表示字符串S的长度。 第四行输入字符串S。 输出格式 共一行，输出所有出现位置的起始下标（下标从0开始计数），整数之间用空格隔开。 数据范围 1≤N≤1051≤N≤10^51≤N≤105 1≤M≤1061≤M≤10^61≤M≤106 输入样例： 3 aba 5 ababa 输出样例： 0 2 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 1e5 + 10 , M = 1e6 + 10; int n , m; char p[N] , s[M]; int ne[N]; int main() { scanf(&quot;%d%s%d%s&quot; , &amp;n , p + 1 , &amp;m , s + 1); for(int i = 2 , j = 0; i &lt;= n; i ++) { while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if(p[i] == p[j + 1]) j ++; ne[i] = j; } for(int i = 1 , j = 0; i &lt;= m; i ++) { while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; if(s[i] == p[j + 1]) j ++; if(j == n) { j = ne[j]; printf(&quot;%d &quot; , i - n); } } return 0; } 引用 理解kmp的过程挺痛苦的，分享一下我看的那些文章吧 阮一峰的网络日志 字符串匹配的KMP算法 书圈 史上最简(详细)KMP算法讲解，看不懂算我输！ CSDN 漫画：什么是KMP算法？ 阮行止 如何更好地理解和掌握 KMP 算法? ","link":"https://solitudealma.github.io/post/kmp/"},{"title":"二维差分","content":"今天我们来讲一下二维差分 什么是二维差分呢？ 相信了解一维差分的小伙伴都知道，差分和前缀和其实是互逆的。二位前缀和是计算矩阵中的一个点包括其和左上角的所有点的值的和，那么差分的作用就是在时间复杂度是 O(1)O(1)O(1) 的情况下对一个矩阵操作，比如某区域的点都加上一个数。 那么我们应该怎么构建差分数组呢，其实和一维差分差不多，只不过是多了一维。那么有了一维差分的构建经验对于二位差分我们直接用插入函数即可，原理下面会说。 由一维差分我们可以知道， a[i] 是 b[1]...b[i] 的前缀和，如果我们要对区间 [l , r] 中的数都加上一个数c的话只需要让 b[l] += c 并且 b[r + 1] -= c 即可，这样用差分数组构建新数组时，区间 [l , r] 中的数都会在原基础上加上c。 如果我们把这个区间放缩一下，并且让数组元素都为0的这个数组a作为我们的原数组，那么数组a的差分数组b也是全为0，这样我们就构成了差分数组，那么我们真正需要输入到数组中的数就可以利用二位差分的性质进行了，也就是当区间 l = r时，我们让其加上一个需要输入的数，这样既输入了数据，也构成了差分数组。 我们来看一下对任意子矩阵都加上一个数的话，应该怎么利用差分数组。 从图中我们可以很清楚的看到，如果在x1，y1上加一个数c那么它右下角的数都会加上c，那么该怎么办呢，其实这也是容斥定理。我们只需要减去右边多加的部分和下边多加的部分最后再加上重复减去的部分即可 那么代码该怎么写呢，我们来看看模板吧 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 其实挺简单的，我们来做一道模板题熟悉一下吧 AcWing 798.差分矩阵 题目描述 输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。 每个操作都要将选中的子矩阵中的每个元素的值加上c。 请你将进行完所有操作后的矩阵输出。 输入格式 第一行包含整数n,m,q。 接下来n行，每行包含m个整数，表示整数矩阵。 接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。 输出格式 共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。 数据范围 1≤n,m≤1000,1≤n,m≤1000,1≤n,m≤1000, 1≤q≤100000,1≤q≤100000,1≤q≤100000, 1≤x1≤x2≤n,1≤x1≤x2≤n,1≤x1≤x2≤n, 1≤y1≤y2≤m,1≤y1≤y2≤m,1≤y1≤y2≤m, −1000≤c≤1000,−1000≤c≤1000,−1000≤c≤1000, −1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000 输入样例： 3 4 3 1 2 2 1 3 2 2 1 1 1 1 1 1 1 2 2 1 1 3 2 3 2 3 1 3 4 1 输出样例： 2 3 4 1 4 3 4 1 2 2 2 2 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 1010; int n , m , q; int a[N][N] , b[N][N]; void insert(int x1 , int y1 , int x2 , int y2 , int c) { b[x1][y1] += c; b[x1][y2 + 1] -= c; b[x2 + 1][y1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { scanf(&quot;%d%d%d&quot; , &amp;n , &amp;m , &amp;q); for(int i = 1; i &lt;= n; i ++) { for(int j = 1; j &lt;= m; j ++) { scanf(&quot;%d&quot; , &amp;a[i][j]); insert(i , j , i , j , a[i][j]); } } while(q --) { int x1 , y1 , x2 , y2 , c; scanf(&quot;%d%d%d%d%d&quot; , &amp;x1 , &amp;y1 , &amp;x2 , &amp;y2 , &amp;c); insert(x1 , y1 , x2 , y2 , c); } for(int i = 1; i &lt;= n; i ++) { for(int j = 1; j &lt;= m; j ++) { b[i][j] += b[i - 1][j] + b[i][j -1] - b[i - 1][j - 1]; printf(&quot;%d &quot; , b[i][j]); } puts(&quot;&quot;); } return 0; } 引用 引用一些大佬的题解 p_c AcWing 798. 差分矩阵 dongwa_zzuli AcWing 798. 差分矩阵_java vanilla AcWing 798. 差分矩阵 ","link":"https://solitudealma.github.io/post/two_dimensional_difference/"},{"title":"二位前缀和","content":"今天我们来讲一下二位前缀和 什么叫二位前缀和呢？ 给我们一个 n×mn \\times mn×m 的矩阵，矩阵中任意一点的左上角的点的数之和加上这个点的值为该点的二维前缀和 s[i][j]=∑i=1...ij=1...ja[i][j]s[i][j]=\\sum_{i=1...i}^{j=1...j} a[i][j]s[i][j]=∑i=1...ij=1...j​a[i][j]。 那么我们应该怎么用公式求呢？ 首先我们用s数组来表示前缀和，那么 s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i- 1][j - 1] + a[i][j] ，即这一个点的二位前缀和等于它左边的点和上面的点的前缀和之和减去左上角的点的前缀和（即多加的部分）再加上这个点的值就是该点的二维前缀和，其实就是容斥定理。可以结合下图理解。 橙色部分是左边的点的前缀和，红色部分是上面的点的前缀和，绿色的点是重复部分，褐色是当前的点 既然我们求出了每一个点对应的二维前缀和，那么如果需要求子矩阵的二维前缀和呢，该怎么求。 其实也很简单，从定义出发，以（x1，y1）为左上角，（x2，y2）为右上角的子矩阵的前缀和可以看成是（x2，y2）的前缀和减去（x2，y1-1）的前缀和再减去（x1-1，y2）的前缀和最后再加上（x1-1，y1-1）的前缀和即可。用公式表示就是 s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1] 。可以结合下图理解。 红色部分为所求区域，绿色和橙色是多余部分要减去，而灰色部分是多减了要加回来。 到这里相信你也懂得了怎么求矩阵的二维前缀和，那么我们直接上模板吧 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 接着我们来做一道模板题 AcWing 796.子矩阵的和 题目描述 输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。 对于每个询问输出子矩阵中所有数的和。 输入格式 第一行包含三个整数n，m，q。 接下来n行，每行包含m个整数，表示整数矩阵。 接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。 输出格式 共q行，每行输出一个询问的结果。 数据范围 1≤n,m≤1000,1≤n,m≤1000,1≤n,m≤1000, 1≤q≤200000,1≤q≤200000,1≤q≤200000, 1≤x1≤x2≤n,1≤x1≤x2≤n,1≤x1≤x2≤n, 1≤y1≤y2≤m,1≤y1≤y2≤m,1≤y1≤y2≤m, −1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000 输入样例： 3 4 3 1 7 2 4 3 6 2 8 2 1 2 3 1 1 2 2 2 1 3 4 1 3 3 4 输出样例： 17 27 21 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 1010; int n , m , q; int a[N][N] , s[N][N]; int main() { scanf(&quot;%d%d%d&quot; , &amp;n , &amp;m , &amp;q); for(int i = 1; i &lt;= n; i ++) for(int j = 1; j &lt;= m; j ++) scanf(&quot;%d&quot; , &amp;a[i][j]) , s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; while(q --) { int x1 , y1 , x2 , y2; scanf(&quot;%d%d%d%d&quot; , &amp;x1 , &amp;y1 , &amp;x2 , &amp;y2); printf(&quot;%d\\n&quot; , s[x2][y2] - s[x2][y1 - 1] - s[x1 - 1][y2] + s[x1 - 1][y1 - 1]); } return 0; } 引用 引用一下大佬的题解 Bug_FreeOωO AcWing 796. 子矩阵的和 zning AcWing 796. 子矩阵的和_Java ","link":"https://solitudealma.github.io/post/two_dimensional_prefix_sum/"},{"title":"一维差分","content":"今天我们来讲一下一维差分 什么是差分呢？ 其实差分和前缀和是逆运算，由定义 b[i]=a[i]-a[i-1] ;可得 a[i]=∑j=1ib[j]a[i] = \\displaystyle\\sum_{j = 1}^i b[j]a[i]=j=1∑i​b[j] ,那么就称b是a的差分数组。差分数组可以将对a数组任意区间的同一操作优化到O(1)O(1)O(1) 那么构造差分数组其实也挺简单的，用第i个元素减去第i-1个元素存入b[i]即可 常见的一维差分操作是令某一段区间的数同时加上一个数，我们利用定义出发很容易就能想到只要在区间起点位置加上一个数就行了，但是这样的话我们构成的新数组就是从起点开始以后的数都加上一个数，因为我们想要的只是一段区间，所以只需要在终点的下一个位置减去这个数即可 我们来看看模板吧 b[l] += c; b[r + 1] -= c; 其实在我们构造一维差分数组是有一个更便捷的方法，就是将一段区间加上一个数这一操作特殊化。 我们将差分数组初始化为0，这时原数组也是0，可以看成b数组是a数组的差分数组，而a数组则是b数组的前缀和数组。那么我们需要对a数组输入数据，就可以看成是对 [i , i] 这个区间加上一个数，那么进行n次操作后我们就可以构造出一个新的差分数组了，因为后续我们需要对一段区间操作，所以利用这一性质我们可以直接合并这一操作，使其利用率更大2333 那么我们直接用模板题试一下吧 AcWing 797.差分 题目描述 输入一个长度为n的整数序列。 接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。 请你输出进行完所有操作后的序列。 输入格式 第一行包含两个整数n和m。 第二行包含n个整数，表示整数序列。 接下来m行，每行包含三个整数l，r，c，表示一个操作。 输出格式 共一行，包含n个整数，表示最终序列。 数据范围 1≤n,m≤100000,1≤n,m≤100000,1≤n,m≤100000, 1≤l≤r≤n,1≤l≤r≤n,1≤l≤r≤n, −1000≤c≤1000,−1000≤c≤1000,−1000≤c≤1000, −1000≤整数序列中元素的值≤1000−1000≤整数序列中元素的值≤1000−1000≤整数序列中元素的值≤1000 输入样例： 6 3 1 2 2 1 2 1 1 3 1 3 5 1 1 6 1 输出样例： 3 4 5 3 4 2 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 100010; int a[N] , b[N]; int n , m; void insert(int l , int r , int c) { b[l] += c; b[r + 1] -= c; } int main() { scanf(&quot;%d%d&quot; , &amp;n , &amp;m); //这里其实也可以不用a数组，用变量也行，但是可能后续需要用到和为了方便理解，所以用到了a数组 for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot; , &amp;a[i]) , insert(i , i , a[i]); while(m --) { int l , r , c; scanf(&quot;%d%d%d&quot; , &amp;l , &amp;r , &amp;c); insert(l , r , c); } // 只需对差分数组求前缀和即可得到操作后的新数组 for(int i = 1; i &lt;= n; i ++) b[i] = b[i - 1] + b[i] , printf(&quot;%d &quot; , b[i]); return 0; } 引用 引用一下我觉得还不错的题解，我解释的可能稍微抽象点 dongwa_zzuli AcWing 797. 差分_java z林深时见鹿 AcWing 797. 差分 【c++详细题解】 自由周某 AcWing 797. 差分 ","link":"https://solitudealma.github.io/post/one_dimensional_difference/"},{"title":"一维前缀和","content":"今天我们来讲讲一维前缀和 首先我们来介绍一下一维前缀和，emmm其实和数列的前n项和差不多，它能在 O(1)O(1)O(1) 的时间复杂度操作数组的任意子区间，比如我们要找出一段区间的和。 我们先预处理出一个前缀和数组，为了方便使用，前缀和数组下标从1开始，数组初始化时我们看作原数组是一个元素全为0的数组，这个在输入数据的同时我们就能对其一边输入一边求前缀和，当然要是不能理解，也是可以分步的 前缀和数组我们用s表示，那么 s[1] 的计算就能看成是 s[0] + a[1] ，即起始下标到当前下标的区间前缀和为 s[i - 1] + a[i] 。那么如果我们要求任意一段区间的前缀和呢？其实也很简单，区间 [l , r] 的前缀和为 a[l] + ... + a[r] 等价于 s[r] - s[l - 1]。 比如我们要求区间3-5的前缀和，那么其实相当于1-5这个区间的前缀和减去1-2这个区间的前缀和 模板其实也很简单 S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] 那么我们直接来做模板题吧 AcWing 795.前缀和 题目描述 输入一个长度为 n 的整数序列。 接下来再输入 m 个询问，每个询问输入一对 l,r。 对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。 输入格式 第一行包含两个整数 n 和 m。 第二行包含 n 个整数，表示整数数列。 接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。 输出格式 共m行，每行输出一个询问的结果。 数据范围 1≤l≤r≤n,1≤l≤r≤n,1≤l≤r≤n, 1≤n,m≤100000,1≤n,m≤100000,1≤n,m≤100000, −1000≤数列中元素的值≤1000−1000≤数列中元素的值≤1000−1000≤数列中元素的值≤1000 输入样例： 5 3 2 1 3 6 4 1 2 1 3 2 4 输出样例： 3 6 10 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 100010; int a[N] , s[N]; int main() { int n , m; scanf(&quot;%d%d&quot; , &amp;n , &amp;m); for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot; , &amp;a[i]) , s[i] = s[i - 1] + a[i]; while(m --) { int l , r; scanf(&quot;%d%d&quot; , &amp;l , &amp;r); printf(&quot;%d\\n&quot; ,s[r] - s[l - 1]); } return 0; } 引用 引用一些大佬的题解，他们解释得比较清楚 z林深时见鹿 AcWing 795. 前缀和 【c++详细题解】 Bug_FreeOωO AcWing 795. 前缀和 zning AcWing 795. 前缀和理解_Java ","link":"https://solitudealma.github.io/post/one_dimensional_prefix_sum/"},{"title":"高精度除法的介绍以及模板的分享","content":"今天我们来介绍一下高精度除法 什么是高精度除法呢？ 我们来看看百度百科是怎么介绍高精度除法的，但是并没有搜到相关信息，逛了一圈发现也没人介绍，那我在这里就简单提一下。 一般我们计算高精度除法分为高精度除高精度和高精度除低精度，在这里我们只讲第二种，计算的过程很多时候都是不能整除的，所以我们需要计算商与余数，计算过程也非常简单。 首先我们回想一下在草稿纸上我们是如何计算的，第一步看最高位，最高位除以除数作为商的第一位，对除数求余作为下一步计算的数的一部分，每一次求余过后我们都让余数扩大10倍再加上下一位，如此往复计算即可。 那么我们来看看模板是怎么写的 vector&lt;int&gt; div(vector&lt;int&gt; &amp;A , int b , int &amp;r) { vector&lt;int&gt; C; r = 0; //余数，这里用到了C++的引用，所以返回的时候可以不用返回余数 // 这里正着算，从最高位开始 for(int i = A.size() - 1; i &gt;= 0; i --) { r = r * 10 + A[i]; //计算当前被减数大小 C.push_back(r / b); //计算当前商的对应位数 r %= b; // 更新余数 } reverse(C.begin() , C.end()); //这里将数组翻转过来，因为我们需要去掉前导零 while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 接下来试试模板题吧 AcWing 794.高精度除法 题目描述 给定两个非负整数A，B，请你计算 A / B的商和余数。 输入格式 共两行，第一行包含整数A，第二行包含整数B。 输出格式 共两行，第一行输出所求的商，第二行输出所求余数。 数据范围 1≤A的长度≤100000,1≤A的长度≤100000,1≤A的长度≤100000, 1≤B≤100001≤B≤100001≤B≤10000 B一定不为0B 一定不为0B一定不为0 输入样例： 7 2 输出样例： 3 1 C++代码 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; vector&lt;int&gt; A; string a; int b; vector&lt;int&gt; div(vector&lt;int&gt; &amp;A , int b , int &amp;r) { vector&lt;int&gt; C; r = 0; for(int i = A.size() - 1; i &gt;= 0; i --) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin() , C.end()); while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; // 因为高精度计算往往并不是单单一个，而是两三个一起，所以我们在这里统一存入方式，避免不必要的错误 for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - '0'); int r; auto C = div(A , b, r); for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; cout &lt;&lt; endl &lt;&lt; r; return 0; } 引用 引用一些比较好的题解，比较详细有配图 空_22 AcWing 794. 基础_高精度_高精度除法java_python_c++ zyz. AcWing 794. 高精度除法 Bug_FreeOωO AcWing 794. 高精度除法 ","link":"https://solitudealma.github.io/post/high_precision_division/"},{"title":"高精度乘法的介绍以及模板的分享","content":"今天我们来讲讲高精度乘法 什么是高精度乘法呢？ 我们来看看百度百科什么介绍高精度乘法的，同样是因为存储数据的问题，大整数的乘法必定会有溢出的时候，那么我们应该怎么计算呢 其实乘法的计算也不难，我们这里会介绍高精度与高精度的乘法以及高精度与低精度的乘法，乘法我们用草稿纸演算的时候是按位相乘，就是一个数的每一位乘另一个数的每一位，然后再错位相加（注意不是数列求和的错位相加），还需注意前导零的情况，虽然乘法不会出现前导零，但是因为我们模板的原因，其中一个乘数为零是是会出现一堆零的，所以我们需要去掉多余的零 高精度乘低精度就很简单了，首先我们先把数字倒序存入数组中，然后用数组中的每一位去乘低精度的数对10取余存入结果数组，然后保留进位继续下一次计算，当然你可能会问万一乘出来的数用 unsigned long long 都存不了呢，我只能说这种情况只能用高精度乘高精度的模板了，而且既然题目的意思是高精度乘低精度就不会让你溢出 高精度乘高精度也不难，就是复现了草稿纸上的计算过程 我们直接上模板吧 // 高精度乘低精度 vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A , int b) { vector&lt;int&gt; C; int t = 0; // 循环的判断是如果A算完了，但是最高位要进位需要再算一次，当然分离出去也行 for(int i = 0; i &lt; A.size() || t; i ++) { if(i &lt; A.size()) t += A[i] * b; //if的判断配合循环判断 C.push_back(t % 10); //模10就是我们要的结果 t /= 10; // 保留进位 } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); //如果乘数为零则去前导零 return C; } // 高精度乘高精度 vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C(A.size() + B.size() , 0); //初始化，以免里面的数不是零，用于但是存相加的对应位结果 int t = 0; // 计算对应位相加后的结果 for(int i = 0; i &lt; A.size(); i ++) for(int j = 0; j &lt; B.size(); j ++) C[i + j] += A[i] * B[j]; // 计算对应位真正的结果 for(int i = 0; i &lt; C.size(); i ++) { t += C[i]; C[i] = t % 10; t /= 10; } // 去前导零，以免出现这种情况 while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } 接下来我们来一道模板题 AcWing 793.高精度乘法 题目描述 给定两个正整数A和B，请你计算A * B的值。 输入格式 共两行，第一行包含整数A，第二行包含整数B。 输出格式 共一行，包含A * B的值。 数据范围 1≤A的长度≤100000,1≤A的长度≤100000,1≤A的长度≤100000, 0≤B≤100000≤B≤100000≤B≤10000 输入样例： 2 3 输出样例： 6 C++代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A; string a; int b; vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A , int b) { vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; A.size() || t; i ++) { if(i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); auto C = mul(A , b); for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; return 0; } 引用 引用一些大佬的题解，其中有高精度乘高精度的模板，思路很不错orz，也有java的实现以及数组的实现 Anish AcWing 793. 高精度乘法 A x b 和 A x B 的模版 师大专升本16级学长 AcWing 793. 高精度乘法（C语言新手版） 小呆呆 AcWing 793. 高精度乘法 ","link":"https://solitudealma.github.io/post/high_precision_multiplication/"},{"title":"题解：AcWing 792.高精度减法","content":"题目链接 AcWing 792.高精度减法 引用 数组实现的看一看下面引用的题解；也有Java的实现方法，虽然Java有大数类；对压位感兴趣的小伙伴也可以看看 师大专升本16级学长 AcWing 792. 高精度减法（C语言新手版） jasonlin AcWing 792. 高精度减法 小呆呆 AcWing 792. 高精度减法 Accepting AcWing 792. 高精度减法(压位) 题目描述 给定两个正整数，计算它们的差，计算结果可能为负数。 样例 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的差。 数据范围 1≤整数长度≤1051≤整数长度≤1051≤整数长度≤105 输入样例： 32 11 输出样例： 21 算法 (高精度减法) O(n)O(n)O(n) 高精度减法和加法区别不大，存储的时候我们也是倒序存入数组中，因为我们都知道，减法的过程中是会向前借位的，同样的，如果最高位是1，借位后为0，那么我们就不能够直接输出数组元素，必须先去掉前导零；还有就是因为减法是会产生负数，所以在计算之前我们应该先比较两个数的大小，通过数组长度以及从最高位开始对应位的大小；还有就是借位了，有一个很巧妙的计算借位相减后的数字， (t + 10) % 10 怎么理解呢， t存的是对应位相减的结果无论结果是正数还是负数，计算后都会得到正确的结果，然后根据t是否大于零来判断是否借位了。 负数记得输出负号哦~~~ 时间复杂度 O(n)O(n)O(n) 根据数的长度决定循环的次数，所以时间复杂度也是线性的 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; bool cmp(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() != B.size()) return A.size() &gt; B.size(); for(int i = A.size() - 1; i &gt;= 0; i --) if(A[i] != B[i]) return A[i] &gt; B[i]; return true; } vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; A.size(); i ++) { t = A[i] - t; if(i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if(t &lt; 0) t = 1; else t = 0; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - '0'); vector&lt;int&gt; C; if(cmp(A , B)) C = sub(A , B); else C = sub(B , A) , cout &lt;&lt; '-'; for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; return 0; } ","link":"https://solitudealma.github.io/post/AcWing792/"},{"title":"高精度减法的介绍以及模板的分享","content":"今天我们来讲一下高精度减法 首先什么是高精度减法呢？☹️☹️☹️ 我们来看一下百度是怎么介绍高精度减法的,没想到百度居然偷懒，那我也顺带放上高精度加法的介绍吧。 也可以看看我之前对于高精度加法的介绍 高精度减法和加法区别不大，存储的时候我们也是倒序存入数组中，因为我们都知道，减法的过程中是会向前借位的，同样的，如果最高位是1，借位后为0，那么我们就不能够直接输出数组元素，必须先去掉前导零；还有就是因为减法是会产生负数，所以在计算之前我们应该先比较两个数的大小，通过数组长度以及从最高位开始对应位的大小；还有就是借位了，有一个很巧妙的计算借位相减后的数字， (t + 10) % 10 怎么理解呢， t存的是对应位相减的结果无论结果是正数还是负数，计算后都会得到正确的结果，然后根据t是否大于零来判断是否借位了。 负数记得输出负号哦~~~ 接下来我们来看看模板👇👇👇 bool cmp(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() != B.size()) return A.size() &gt; B.size();// 如果位数不相等，返回A &gt; B 的结果 // 遍历A与B的每一位，此时位数相同，用A或者B的size都行，只要有一位不同，就返回A[i] &gt; B[i] 的结果 for(int i = A.size() -1; i &gt;= 0; i --) if(A[i] != B[i]) return A[i] &gt; B[i]; return true; } vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C; // 存放结果 int t = 0; // 记录是否借位 for(int i = 0; i &lt; A.size(); i ++) { t = A[i] - t; //减去借位 if(i &lt; B.size()) t -= B[i]; //未减完就继续减 C.push_back((t + 10) % 10); //放入对应位结果 if(t &lt; 0) t = 1; //判断是否借位，小于零则借位 else t = 0; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); //去前导零 return C; } cmp函数是比较减数与被减数的大小，sub函数就是减法的具体内容了 模板内容就这么多，很好理解的，输出的时候记得倒序输出 那么我们来一道模板题练练手👏👏👏 AcWing 792. 高精度减法 题目描述 给定两个正整数，计算它们的差，计算结果可能为负数。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的差。 数据范围 1≤整数长度≤1051≤整数长度≤1051≤整数长度≤105 输入样例： 32 11 输出样例： 21 C++代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; bool cmp(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() != B.size()) return A.size() &gt; B.size(); for(int i = A.size() - 1; i &gt;= 0; i --) if(A[i] != B[i]) return A[i] &gt; B[i]; return true; } vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; A.size(); i ++) { t = A[i] - t; if(i &lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if(t &lt; 0) t = 1; else t = 0; } while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; for(int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); for(int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - '0'); vector&lt;int&gt; C; if(cmp(A , B)) C = sub(A , B); else C = sub(B , A) , cout &lt;&lt; '-' ; for(int i = C.size() - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; return 0; } 引用 数组实现的看一看下面引用的题解；也有Java的实现方法，虽然Java有大数类；对压位感兴趣的小伙伴也可以看看🤺🤺🤺 师大专升本16级学长 AcWing 792. 高精度减法（C语言新手版） jasonlin AcWing 792. 高精度减法 小呆呆 AcWing 792. 高精度减法 Accepting AcWing 792. 高精度减法(压位) ","link":"https://solitudealma.github.io/post/high_precision_subtraction/"},{"title":"题解：AcWing 791.高精度加法","content":"题目链接 AcWing 791. 高精度加法 引用 引用一下大佬的题解，其中有用数组实现的，也有Java的实现，也有string的实现以及压位，大佬们也太厉害了，orz~~~ lyclyc_NSP AcWing 791. 高精度加法C++数组实现 小呆呆 AcWing 791. 高精度加法 二月 AcWing 791. 高精度加法（使用string，30行） c++ 就是个渣渣 AcWing 791. 高精度加法 题目描述 给定两个正整数，计算它们的和。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的和。 数据范围 1≤整数长度≤1000001≤整数长度≤1000001≤整数长度≤100000 输入样例： 12 23 输出样例： 35 算法 (高精度加法) O(n)O(n)O(n) 高精度加法其实不难，首先我们肯定是存不下这个数的，所以可以用字符数组或者string读取，然后倒序存入vector中，加法计算过程只要注意进位即可，还有最高位可能要进位，所以需要判断一下 时间复杂度 O(n)O(n)O(n) 根据数的长度决定循环的次数，所以时间复杂度也是线性的 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; vector&lt;int&gt; add(vector&lt;int&gt; &amp;A ,vector&lt;int&gt; &amp;B) { if(A.size() &lt; B.size()) return add(B , A); vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; (int)A.size(); ++ i) { t += A[i]; if(i &lt; (int)B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; // a[i] - '0' 是通过ACII码的差值计算该字符转为数字时的大小 for(int i = a.size() - 1; i &gt;= 0; -- i) A.push_back(a[i] - '0'); for(int j = b.size() - 1; j &gt;= 0; -- j) B.push_back(b[j] - '0'); // auto是C++11的新特性，编译器会自动识别变量的类型，相当方便，如果不可以用，那就用标识符定义吧 auto C = add(A , B); for(int k = C.size() - 1; k &gt;= 0; -- k) cout &lt;&lt; C[k]; return 0; } ","link":"https://solitudealma.github.io/post/AcWing791/"},{"title":"高精度加法的介绍以及模板的分享","content":"简单介绍一下高精度加法（高精度加高精度或低精度都可以用） 什么是高精度加法呢？🤣🤣🤣 简单点说就是当我们计算的时候，如果数据过大，那么我们使用的数据类型可能存不下，比如 int 的范围是 $-2^{31} $ ~ 231−12^{31}-1231−1（中间有个0），那么你存的数的位数不能超过9位数，但是很多时候数据都会很大，有些人会说，那我用 long 也行啊，我只能说有时候你用 unsigned long long 都不够，可见数据位数之长。 详情可以看看这个高精度算法😘😘😘 这里我们只解决高精度整数加法，一般也不考浮点数吧，emmm😜😜😜 那这种数据我们应该怎么处理呢？很简单。既然存不下，那我们就用字符串（字符数组也行，C++特有的数据类型string，其实也等价于字符数组，只不过更方便使用）读入，然后将其每一位存入数组中即可，只要我们的数组够大，就能完成我们的计算（不TLE的前提，既然题目明确要用这种方法就不会让你超时）。 但是对于加法我们都知道的一点，也是最重要的一点。那就是十进制数是满十进一，因为我们是用数组去存数的每一位，所以在计算的时候我们应该倒序存数的每一位，即数组的第一位存的不是最高位而是最低位，这样在我们进位的时候会更加方便（最高位可能也要进位，而这时数组第0位已经有数了，再放就越界了，得把数组中的数往后移，这样就会特别麻烦）。 那么我们先看看模板是怎样的👇👇👇 不知道vector的小伙伴可以看看这个vector介绍 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 vector&lt;int&gt; add(vector&lt;int&gt; &amp;A , vector&lt;int&gt; &amp;B) { if(A.size() &lt; B.size()) return add(B , A);//如果被加数长度小于加数那么就调整顺序，如果不加这一句就需要变动一下for循环，i多判断一次是否小于B的大小（即算完最长的数的位数才停），然后 t += A[i] 用 if(i &lt; A.size())包裹 vector&lt;int&gt; C;// 定义一个答案 int t = 0; // 存储进位 for(int i = 0; i &lt; A.size(); ++ i) { t += A[i]; if(i &lt; B.size()) t += B[i]; //如果B还没加完就继续 C.push_back(t % 10); // mod 10 的结果就是对应位的结果 push_back 是往数组后面插入一个数 t /= 10; //整除10表示进位是多少 } if(t) C.push_back(c); // t为0，表示最高位无进位，大于0表示有进位。也可以写入for循环，自行思考 return C; } 这个模板并不难理解，输出答案的时候记得倒序输出就是了。 我们直接上模板题👇👇👇 AcWing 791. 高精度加法 题目描述 给定两个正整数，计算它们的和。 输入格式 共两行，每行包含一个整数。 输出格式 共一行，包含所求的和。 数据范围 1≤整数长度≤1000001≤整数长度≤1000001≤整数长度≤100000 输入样例： 12 23 输出样例： 35 C++ 代码 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; A , B; string a , b; vector&lt;int&gt; add(vector&lt;int&gt; &amp;A ,vector&lt;int&gt; &amp;B) { if(A.size() &lt; B.size()) return add(B , A); vector&lt;int&gt; C; int t = 0; for(int i = 0; i &lt; (int)A.size(); ++ i) { t += A[i]; if(i &lt; (int)B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if(t) C.push_back(t); return C; } int main() { cin &gt;&gt; a &gt;&gt; b; // a[i] - '0' 是通过ACII码的差值计算该字符转为数字时的大小 for(int i = a.size() - 1; i &gt;= 0; -- i) A.push_back(a[i] - '0'); for(int j = b.size() - 1; j &gt;= 0; -- j) B.push_back(b[j] - '0'); // auto是C++11的新特性，编译器会自动识别变量的类型，相当方便，如果不可以用，那就用标识符定义吧 auto C = add(A , B); for(int k = C.size() - 1; k &gt;= 0; -- k) cout &lt;&lt; C[k]; return 0; } 引用 有大佬用数组写了一遍，可以参考，记得去前导零，因为开数组的时候都是比数据范围大，（emmm，其实也可以不用，不过写成函数的话可以搞个计数器，记录位数，然后输出2333，灵活运用吧），orz Java的小伙伴也可以学一下，貌似有些题目不能用Big Integer，毕竟算法这个东西学到一点是一点，不能因为语言特性而不去学 还有一点就是用数组貌似比STL快了一倍，不过这时差可以忽略不计，但是比如链表的操作这些用数组作为静态链表去模拟的话速度会快很多，而且写法也简单，特别是数据很大的时候，用数组往往是很好的选择，当然这也是后话了 对于压位感兴趣的小伙伴也可以试试，引用的题解中有，但是一般应该用不上 lyclyc_NSP AcWing 791. 高精度加法C++数组实现 小呆呆 AcWing 791. 高精度加法 二月 AcWing 791. 高精度加法（使用string，30行） c++ 就是个渣渣 AcWing 791. 高精度加法 ","link":"https://solitudealma.github.io/post/high_precision_addition/"},{"title":"题解：AcWing 790.数的三次方根","content":"题目链接 AcWing 790.数的三次方根 引用 引用一下还不错的题解 第一WA者金银花 AcWing 790. 数的三次方根 zning AcWing 790. 浮点数二分法_Java modeming AcWing 790. 数的三次方根（牛顿迭代法） 题目描述 给定一个浮点数n，求它的三次方根。 样例 输入格式 共一行，包含一个浮点数n。 输出格式 共一行，包含一个浮点数，表示问题的解。 注意，结果保留6位小数。 数据范围 −10000≤n≤10000−10000≤n≤10000−10000≤n≤10000 输入样例： 1000.001000.001000.00 输出样例： 10.00000010.00000010.000000 算法 (浮点数二分) O(n)O(n)O(n) 关于浮点数二分就没什么好说的了，因为精度问题，像三次方根平方根这些都只能找到大概的范围，所以我们只要不断缩小范围即可，设定一个精度eps，如果题目说精确到6位，那我们设置的精度就为 1e−81e-81e−8。 有一个需要注意的点是，求平方根时，如果输入的数是 &lt; 1 &amp;&amp; &gt;0，那么计算的时候就要注意了，比如0.1的平方根，那么答案肯定是在0.1到1之间，所以应该特殊处理区间更新方式 时间复杂度 O(n)O(n)O(n) 最多查找 n/2n/2n/2 次，所以时间复杂度是线性的 C++ 代码 #include &lt;cstdio&gt; using namespace std; double n; int main() { scanf(&quot;%lf&quot; , &amp;n); double l = -1000 , r = 1000 , eps = 1e-8; while(r - l &gt; eps) { double mid = (l + r) / 2; if(mid * mid * mid &gt;= n) r = mid; else l = mid; } printf(&quot;%.6lf&quot; , l); return 0; } ","link":"https://solitudealma.github.io/post/AcWing790/"},{"title":"2021.02.19 [日记]","content":"又是摸鱼的一天，一直睡到10点多才起床。起床后想到了可以给GitHub Pages改个自定义域名，u1s1，仓库名访问真的又臭又长，说干就干，百度了一下怎么操作。哦，越来加上A记录和CNAME记录就行啦，那简单，ping了一下原来的域名，搞到了ip，然后在仓库设置里填子域名即可，接着一通操作，ojbk。一访问，？？？，样式去哪了？出你妈大事。并且Github告诉我，我的DNS还未生效 Domain's DNS record could not be retrieved. 。然后我想了一下，可能是我配置的同时把DNS服务器从阿里云的改成了腾讯云。所以提示了这个？然后我又重新填了一边，发现，诶？可以正常访问了。晚上看了一下大佬的回答说是因为Github用了cdn，所以依然会有那个提示，具体原因不太清楚，反正能用就行2333。 昨晚帮一个初中生解决了个小问题，然后突然提到他朋友6年级就搭建了一个OJ平台和博客，初中搞信息奥赛的都是大佬，真的是后生可畏啊...当然别人厉害之余我们也应该多去学习，而不是停滞不前，毕竟比你牛的人都在努力，你又有什么理由不努力呢。当他说出OJ平台的时候我下意识的以为是评测系统，也就是测试数据的部分，毕竟刷过题的小伙伴都知道测试数据的部分不好搞，得限制时间和空间，测试结果不能返回过慢，多人同时测试时不能等待时间过长等等一系列优化问题。突然有一种想自己搞一个OJ平台的冲动，然后昨晚睡前简单的百度了一下，发现一个完整的OJ平台包括题库，比赛&amp;作业，排名等等，看来挺有搞头的，而且完成之后对于前后端开发都会有很大的提升。不过很大程度上做不完，哈哈哈。开学再看吧，溜了溜了。 ","link":"https://solitudealma.github.io/post/20200219/"},{"title":"题解：AcWing 789.数的范围","content":"题目链接 AcWing 789.数的范围 引用 引用一下我觉得还不错的题解，%%% 秦淮岸灯火阑珊 AcWing 789. 数的范围 Bug_FreeOωO AcWing 789. 数的范围 醉生梦死 AcWing 789. 二分算法的证明和边界分析 AdaMeta AcWing 789. 二分模板笔记 题目描述 给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。 对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。 如果数组中不存在该元素，则返回“-1 -1”。 样例 输入格式 第一行包含整数n和q，表示数组长度和询问个数。 第二行包含n个整数（均在1~10000范围内），表示完整数组。 接下来q行，每行包含一个整数k，表示一个询问元素。 输出格式 共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回“-1 -1”。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 1≤q≤100001≤q≤100001≤q≤10000 1≤k≤100001≤k≤100001≤k≤10000 输入样例： 6 3 1 2 2 3 3 4 3 4 5 输出样例： 3 4 5 5 -1 -1 算法 (二分) O(n)O(n)O(n) 相信大家在没有学习算法的时候多多少少都对二分法有一定的了解，二分法在查找的过程通过和区间中间值进行比较从而确定所找的值是中间值还是在左区间或是右区间。 一个题目，如果一个区间具有单调性质，那么一定可以二分，但是如果说这道题目没有单调性质，而是具有某种区间性质的话，我们同样可以使用二分。 ——yxc总 常见的可以二分的题 在区间中找一个数 本题中位置的最值即大于等于或小于等于某个值 某个东西是否存在 仔细分析题目意思2333 二分算法在选择区间时，选择的区间一定是存在答案的 做这道题可以直接上模板，但是模板有一些需要注意的地方 比如我们在 1223451 2 2 3 4 5122345 中找到2在序列中第一次出现的位置和最后一次出现的位置，首先我们先确定中间下标，将区间划分为左右两个区间，然后根据check函数判断来更新区间，因为我们需要寻找第一次出现的位置，所以check我们可以这么写 if(a[mid] &gt;= target) r = mid; ，那么最后一次出现就应该是 if(a[mid] &lt;= target) l = mid; 。这里要注意一点，为什么会有两个模板呢，因为区间的更新有两种情况，第一种就是左区间包含mid，第二种就是左区间不包含mid，而我们计算mid的时候是 l + r &gt;&gt; 1 ，当 l+1=rl + 1 = rl+1=r 并且是第二种划分情况时，如果依然是 l + r &gt;&gt; 1 的话，会造成死循环，也就是TLE，区间会一直停留在原地，所以左区间不包含mid时应该向上取整。 当然这两个模板无论哪一个都可以求你要找的那个数，所以如果只出现一次的话哪个都行，也就不存在无限循环的情况！！！ 贴上模板 bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 作者：yxc 链接：https://www.acwing.com/blog/content/277/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 这里再说一下满足某种性质的区间，比如上面找2出现的位置，那么划分区间时，我们根据选的区间是否满足 &gt;=target&gt;= target&gt;=target 或者 &lt;=target&lt;= target&lt;=target 这一性质来判断我们找的数是不是在这个区间 时间复杂度 O(n)O(n)O(n) 最多查找 n/2n/2n/2 次，所以时间复杂度是线性的 C++ 代码 #include &lt;cstdio&gt; using namespace std; const int N = 1e5 + 10; int n , q; int a[N]; int main() { scanf(&quot;%d%d&quot; , &amp;n , &amp;q); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); while(q --) { int k; scanf(&quot;%d&quot; , &amp;k); int l = 0 , r = n - 1; while(l &lt; r) { int mid = l + r &gt;&gt; 1; if(a[mid] &gt;= k) r = mid; else l = mid + 1; } if(a[l] != k) printf(&quot;-1 -1\\n&quot;); else { printf(&quot;%d &quot; , l); l = 0 , r = n - 1;//l可更新可不更新 while(l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if(a[mid] &lt;= k) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot; , l); } } return 0; } ","link":"https://solitudealma.github.io/post/AcWing789/"},{"title":"题解：AcWing 788.逆序对的数量","content":"题目链接 AcWing 788.逆序对的数量 引用 看了大佬的题解后对于归并又有了更深的理解，在这里引用一下dongwa_zzuli大佬的题解AcWing 788. 逆序对的数量，感兴趣的小伙伴可以看看 题目描述 给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。 逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。 样例 输入格式 第一行包含整数n，表示数列的长度。 第二行包含 n 个整数，表示整个数列。 输出格式 输出一个整数，表示逆序对的个数。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 6 2 3 4 5 6 1 输出样例： 5 算法 (归并排序) O(nlogn)O(nlogn)O(nlogn) 做这道题的话因为序列是不能被打乱的，而归并排序开始排序之前，序列还是原来的样子。根据这道题的性质我们可以发现，一共有三种情况，也就是这两个数的位置。 刚好在左区间 刚好在右区间 大的数在左区间，小的数在右区间 前两个情况很好求，在我们处理左右区间时就可以求出来，那么第三种呢。其实也不难，根据归并的性质可以知道在归并到最后一个区间的时候左右两个子区间是有序的，那么我们归并的时候可以判断一下，如果左指针所指的数大于右指针所指的数，那么左指针后的所有数都将大于它，那么这个数构成的逆序对就是 mid - i + 1 ，那么只需将所有这种情况加起来，再加上前两种情况就行了。前两种情况其实在合并为将它们分开时的那个区间时就已经计算完了，只需把 merge_sort(q , l , mid) 和 merge_sort(q , mid + 1 , r) 这两个结果加起来就行了，虽然看上去有点绕，但是如果你知道归并的过程的话，其实就能明白了，还是不太清楚的话建议手动模拟一下，也可以看看我画的图 其实这里还有一个很小的细节，因为我们需要存储逆序对的数量，当序列是倒序的时候逆序列是最多的，即对 n−1+n−2+n−3...+1n-1 + n-2 + n -3 ... + 1n−1+n−2+n−3...+1 ==&gt;&gt; ∑i=1nn\\sum_{i=1}^nn∑i=1n​n 也就是 n(n−1)2\\frac{n(n - 1)}{2}2n(n−1)​ ，当n为 1e51e51e5 时，逆序对的数量为 5×109−5×1045\\times10^9-5\\times10^45×109−5×104，已经超出int的范围了所以我们应该用long或者long long存 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 一共划分 lognlognlogn 次区间，每一层都是n次，所以时间复杂度是 O(nlogn)O(nlogn)O(nlogn) C++ 代码 #include &lt;cstdio&gt; using namespace std; typedef long long LL; const int N = 1e5 + 10; int n; int a[N]; LL merge_sort(int q[] , int l , int r) { if(l &gt;= r) return 0; int mid = l + r &gt;&gt; 1; LL res = merge_sort(q , l , mid) + merge_sort(q , mid + 1 , r); int i = l , j = mid + 1 , k = 0 , temp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(q[i] &lt;= q[j]) temp[k ++] = q[i ++]; else { res += mid - i + 1; temp[k ++] = q[j ++]; } } while(i &lt;= mid) temp[k ++] = q[i ++]; while(j &lt;= r) temp[k ++] = q[j ++]; for(int i = l , j = 0; i &lt;= r; ++ i , ++ j) q[i] = temp[j]; return res; } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); LL res = merge_sort(a , 0 , n - 1); printf(&quot;%lld&quot; , res); return 0; } ","link":"https://solitudealma.github.io/post/AcWing788/"},{"title":"题解：AcWing 786.第K个数","content":"题目链接 AcWing 786.第k个数 引用 星丶空大佬的题解，很不错的思路，奇怪的思路+1 并没有 写一个和yxc大佬不同但差不多思想的方法，代码更简单 题目描述 给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。 样例 输入格式 第一行包含两个整数 n 和 k。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整数数列。 输出格式 输出一个整数，表示数列的第k小数。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000, 1≤k≤n1≤k≤n1≤k≤n 输入样例： 5 3 2 4 1 5 3 输出样例： 3 算法 (快速选择) O(n)O(n)O(n) 从快排的性质可以知道，每次划分区间的时候j左边的数都是小于等于x的，右边的都是大于等于x的。所以如果左区间的长度大于等于k，那么第k个数必定在左区间，所以我们只需递归左区间，反过来，如果k大于左区间长度，那么第k个数在右区间，那么相对于右区间，第k个数在右区间中变为第（k - 左区间的长度）个数，然后递归右区间即可。 时间复杂度 O(n)O(n)O(n) emmm，问就是不知道怎么算的，不过肯定比 O(nlogn)O(nlogn)O(nlogn) 小，等我看了y总的时空复杂度分析再来补吧，哈哈哈 C++ 代码 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1e5 + 10; int n , k; int a[N]; int quick_sort(int q[] , int l , int r , int k) { if(l &gt;= r) return q[l]; int i = l - 1 , j = r + 1 , x = q[l + r &gt;&gt; 1]; while(i &lt; j) { do ++ i; while(q[i] &lt; x); do -- j; while(q[j] &gt; x); if(i &lt; j) swap(q[i] , q[j]); } int len = j - l + 1; if(len &gt;= k) return quick_sort(q , l , j , k); else return quick_sort(q , j + 1 , r , k - len); } int main() { scanf(&quot;%d%d&quot; , &amp;n , &amp;k); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); int res = quick_sort(a , 0 , n - 1 , k); printf(&quot;%d&quot; , res); return 0; } ","link":"https://solitudealma.github.io/post/AcWing786/"},{"title":"对归并排序的一些理解","content":"今天我们来介绍一下归并排序 那么什么是归并排序呢？🤔🤔🤔 百度百科是这么说的:归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 也可以看看动态图😮😮😮 归并排序也和快速排序一样利用分治法来解决问题，同样它也采用了双指针算法（排序的时候），首先将一个有序或者无序的序列按中间索引（下标）分成两个部分，然后再将这两个部分继续分，直到区间长度为1。一个长度为n的区间一共需要分 log2nlog_2nlog2​n 次才能将区间分完。分完区间后就是对区间进行排序，然后合并区间即可。 因为一共需要分 log2nlog_2nlog2​n 次区间，所以归并排序的时间复杂度为 O(nlogn)O(nlogn)O(nlogn) 我们先来看看归并排序的模板👇👇👇 void merge_sort(int q[] , int l , int r) { if(l &gt;= r) return;//区间只有一个数的时候停止递归 int mid = l + r &gt;&gt; 1;//划分区间 merge_sort(q , l , mid) , merge_sort(q , mid + 1 , r);//递归划分左右区间 int i = l , j = mid + 1 , k = 0 , temp[r - l + 1];//i为左区间的指针，j为右区间的指针，k为排序的第几个数，temp数组用于合并区间时临时存储,temp也可以直接开一个和q一样大的全局变量，看个人喜好 //两个区间的数进行比较，小的或者相等的数将左区间的数放入temp，否则右区间放入 while(i &lt;= mid &amp;&amp; j &lt;= r) { if(q[i] &lt;= q[j]) temp[k ++] = q[i ++]; else temp[k ++] = q[j ++]; } // 因为存在还没比较完就有一个区间已经没有数了，所以将剩余的数全部放在temp后，一下while只有一个会执行 while(i &lt;= mid) temp[k ++] = q[i ++]; while(j &lt;= r) temp[k ++] = q[j ++]; for(int i = l , j = 0; i &lt;= r; ++ i , ++ j) q[i] = temp[j];//将temp数组更新到q数组中，q即为排序后的数组 } 归并排序的三个步骤 确定分界点 mid = l + r &gt;&gt; 1; 递归排序左右区间 归并区间❤️❤️❤️ 首先将区间一直划分，直到区间长度为1，接着排序左右区间，最后合并区间。 合并区间之前，区间一定是有序的 从左区间开始排序，此时区间中只有一个3，递归停止（只有一个元素不需要排序），排完后轮到右区间，此时区间中也是只有一个数，不需要排序，递归停止。跳回到上一层递归，然后排序3和1，因为本层递归将区间用mid划分了，也就是意义上的左右区间，形式上还是在同一个数组中，因为 q[i] = 3 是大于 q[j] = 1 的，所以将 q[j] 放入temp数组中，要注意这里的k++，++的位置意味着如果它在一个表达式中的话运算顺序是不一样的，除非它单独为一条语句，那它的位置在哪都一样，如果不能理解的话，单独拎出来自增也是可以的。然后此时 i &gt; mid ，所以while循环停止，接着把未比较完的数放进temp中，这样就合并完第一个区间了，然后更新q数组的前两个位置，如此往复就能把数组排序完了。 老规矩，自己手动模拟的话能更快的理解。 一些细节 k++和++k在单独的一个语句中并没有什么区别，k都会自增。但是如果在一个表达式中的话就不一样了，比如temp[k ++] = q[i ++],在这里是先用k和i的值，然后k和i再加1。我是这么记的，谁在前面谁先执行，即k++是先赋值后加1，++k是先加1后赋值 emmm,好像没有了，有的时候再加上吧 这个算法的难点在于合并区间，必定会有一个区间先比较完，然后得把剩余的所有数全部放入temp数组中，模板中的方法就很不错 又到了呈上例题的时候🤣🤣🤣 AcWing 787. 归并排序 题目描述 给定你一个长度为n的整数数列。 请你使用归并排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式 输入共两行，第一行包含整数 n。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。 输出格式 输出共一行，包含 n 个整数，表示排好序的数列。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 555 312453 1 2 4 531245 输出样例： 123451 2 3 4 512345 C++代码 #include &lt;cstdio&gt; using namespace std; const int N = 100010; int n; int a[N]; void merge_sort(int q[] , int l , int r) { if(l &gt;= r) return; int mid = l + r &gt;&gt; 1; merge_sort(q , l , mid) , merge_sort(q, mid + 1 , r); int i = l , j = mid + 1 , k = 0 , temp[r - l + 1]; while(i &lt;= mid &amp;&amp; j &lt;= r) { if(q[i] &lt;= q[j]) temp[k ++] = q[i ++]; else temp[k ++] = q[j ++]; } while(i &lt;= mid) temp[k ++] = q[i ++]; while(j &lt;= r) temp[k ++] = q[j ++]; for(int i = l , j = 0; i &lt;= r; ++ i , ++ j) q[i] = temp[j]; } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); merge_sort(a , 0 , n - 1); for(int i = 0; i &lt; n; ++ i) printf(&quot;%d &quot; , a[i]); return 0; } 以上就是我对归并算法的一些理解，如有错误的地方请大佬们指出。🤺🤺🤺 ","link":"https://solitudealma.github.io/post/merge_sort/"},{"title":"快速排序的介绍以及算法的模板分享","content":"今天我们来讲一下快速排序 更好的阅读体验 那么什么是快排呢？🤔🤔🤔 百度百科是这么介绍的：快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 也可以看看动态图😮😮😮 它的主要思想是分治法，就是把一个问题分成相互独立的几个规模较小的子问题，然后逐一去解决，最终将得到“母问题的答案”。链接 ==&gt;&gt;分治法 今天我们将采用双指针算法去理解快速排序这一过程，对于双指针算法不太理解的小伙伴可以看看这个介绍 ==&gt;&gt; 算法 | 双指针套路总结 双指针算法基本原理和实践 因为我们是用数组去排序的，所以你只需要知道双指针代表着两个在改变的下标就行了（下标访问本质上也是指针）。 快排的平均时间复杂度为O(nlog2n)O(nlog_2n)O(nlog2​n)，最糟糕的时候是O(n2)O(n^2)O(n2)。 首先我们先给出我们的快排模板👇👇👇 void quick_sort(int q[] , int l , int r) { if(l &gt;= r) return; //表示此区间只有一个数或者没有数 int i = l - 0 , j = r + 1 , x = q[l + r &gt;&gt; 1]; //i为左指针，j为右指针 x为每一次分割区间时选定的比较数 &gt;&gt; 这个是右移运算符，是位运算的一种，将一个整数右移一位表示除以2 while(i &lt; j) { do ++ i; while(q[i] &lt; x); //左指针寻找小于x的数 do -- j; while(q[j] &gt; x); //右指针寻找大于x的数 if(i &lt; j) swap(q[i] &lt; q[j]); //swap函数存在于C++的algorithm头文件中，相当于自己手写的交换变量函数，因为指针停下来的时候可能是穿过，重合这两种情况其中一种，如果未相遇我们就交换指针所指的数，然后直到l&gt;=r循环结束 } //每一次递归之后i、j的相对位置只有两种情况，i==j或者i==j+1 quick_sort(q , l , j) , quick_sort(q , j + 1 , r);//递归处理左右区间，先左，再右（注意划分区间用的是i还是j） } 好了，以上就是我们要用到的快排模板了，一个好的模板能让你快速记忆一个算法，同时它也已经帮我们解决了烦人的边界问题，只需要好好理解记忆即可 快排的三个步骤 确定分界点 q[l] , q[l + r &gt;&gt; 1] , q[r] , 随机 调整区间 保证左边小于等于x，右边大于等于x，x在哪一边都可以💗💗💗 递归处理左右两段 这个模板其实不难理解，函数传入一个含有n个元素的有序或者无序的序列，我们用分治法的思想，首先先确定分界点，因为选取的是l + r &gt;&gt; 1也就是中间元素；而后寻找满足条件的数，直到 l&gt;=rl &gt;= rl&gt;=r ,接着调整区间，将其分为&gt;=x&gt;=x&gt;=x和&lt;=x&lt;=x&lt;=x的两个区间（用j划分，j的左边一定小于等于x，j的右边一定大于等于x）；最后再递归处理左右区间。 如果一个区间只有一个元素，而这个区间又满足小于等于x或者大于等于x这一条件，那么整个合并的区间都是有序的。 一共需要分log2nlog_2nlog2​n次,在第log2nlog_2nlog2​n次时每一个元素都在一个区间里，在那个区间中它是有序的。也是至此递归不再继续，因为区间中只有一个元素（ l&gt;=rl &gt;= rl&gt;=r ），还是不明白的小伙伴可以动手模拟一下，画一下图会清晰很多 一些细节 1.i , j 指针每次都在区间之外，这是因为我们用了do-while循环，每一次指针都是先+1/-1，再判断，这样可以避免死循环等一些迷之操作（其实一般来说都是先判断再操作，这样的话避免回退操作，这里用do-while循环是为了方便理解） 2.选取元素的作为比较的值时尽量不要选取左右端点，因为当序列有序时，时间复杂度会退化为O(n2)O(n^2)O(n2) 3.如果选取右端点，则递归处理的代码为quick_sort(q , l , i - 1) , quick_sort(q , i , r);如果选的是左端点，则为quick_sort(q , l , j) , quick_sort(q , j + 1 , r);；如果选取中间点，两种都可以哦，但是中点选取变为 q[l + r + 1 &gt;&gt; 1] 4.一切有关边界问题的算法都建议背模板，因为这是经过n位大佬试验过的，只需要记就行了 5.如果用的时候无论如何都想不起快排的模板的话，还有一个暴力的方式。1.首先我们先创建a，b两个数组；2.遍历数组q，小于等于x的数放入a中，其他的放入b中；3.将a，b分别排序后，先将a中的元素放入q，再将b中的元素放入q即可 6.最后最后，还是用j做分界点和q[l + r &gt;&gt; 1]做目标值为好，这样能规避所有边界问题 这个算法难点在于调整区间,以j来划分区间的话，在j左边的数都小于等于x，在右边的都大于等于x，其他同理，应该注意你用的是i还是j来划分区间 附上一个简单的快速排序图解 现在我们来写一道模板题 AcWing 785.快速排序 题目描述 给定你一个长度为n的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式 输入共两行，第一行包含整数 n。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。 输出格式 输出共一行，包含 n 个整数，表示排好序的数列。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 5 3 1 2 4 5 输出样例： 1 2 3 4 5 这时候我们直接套用模板既可 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n , a[N]; void quick_sort(int q[] , int l , int r) { if(l &gt;= r) return; int x = q[l + r &gt;&gt; 1] , i = l - 1 , j = r + 1; while(i &lt; j) { do ++ i; while(q[i] &lt; x); do -- j; while(q[j] &gt; x); if(i &lt; j) swap(q[i] , q[j]); } quick_sort(q , l , j) , quick_sort(q , j + 1 , r); } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); quick_sort(a , 0 , n - 1); for(int j = 0; j &lt; n; ++ j) printf(&quot;%d &quot; , a[j]); return 0; } 大家在学算法的时候，特别是学习一个类型题的模板时可以隔三岔五地去敲了两三遍，当然不用追求和模板一致，因为模板是死的，人是活的，只要知道哪里可以变哪里不可以变，灵活运用即可 最后祝大家学习了算法之后，在刷题时能够游刃有余🤺🤺🤺 ","link":"https://solitudealma.github.io/post/quick_sort/"},{"title":"简单介绍一下递归","content":"今天我们来介绍一下递归😤 什么叫递归呢😩，其实说白了就是函数自己调用自己😲。如果还是不明白的小伙伴可以看看百度是怎么介绍的 =&gt;&gt; What is recursion 我第一次认识到递归是因为斐波那契数列。大致是这样的，有这么一个函数F(n)F(n)F(n)，当n=1n=1n=1或者n=2n=2n=2时F(n)=1F(n)=1F(n)=1,当n&gt;2n&gt;2n&gt;2时，F(n)=F(n−1)+F(n−2)F(n)=F(n-1)+F(n-2)F(n)=F(n−1)+F(n−2)。也就是n&gt;2n&gt;2n&gt;2时后面的每一项都等于前两项之和。 用代码来求第n项的话，可以这么写 #include &lt;iostream&gt; using namespace std; int n; int F(int a) { if(a == 0) return 0; else if(a == 1 || a == 2) return 1; //这两个if是递归结束的条件 else return F(a - 1) + F(a - 2); } int main() { cin &gt;&gt; n; cout &lt;&lt; F(n) &lt;&lt; endl; return 0; } 以上就是这简单的递归算法了。 这个代码并不难理解😏。 #include&lt;iostream&gt;这一头文件是C++新加的流输入输出，不懂的话也没关系，看作是scanf(&quot;%d&quot; , &amp;n);就行; using namespace std;也不难理解，C++将标准库中的标识符都放进了std这一命名空间中，为的是保证在同一命名空间中、相同作用域中任何名字都具有唯一性，即不重名。eg：上述代码中引用了iostream这一头文件里的cin函数，用于输入数据；如果不加上这句话，这时候编译器会提示你cin未定义（error: cin was not declared in this scope），相当于你没有引用头文件吧，emmm~~~（应该是这么理解的，大佬不要捶我）。了解过的同学可能会说直接使用命名空间是不太好的，因为你写的这个代码同样可能被其他代码当作头文件引用，会造成命名重复，应该使用什么就加上什么（std::cin）,但是这只是在做项目的时候才会有这种隐患，做题的时候有且只有一个cpp文件，而且你也不想每用一个就加上std吧2333 剩下的就是F这个函数了，递归其实挺好理解的，首先递归必须要有边界条件，否则将会无限递归下去直到栈满。那么你将收到oj（onlinejudge）的Memory Limit Exceeded（emmm，好像不一定是这个，反正意思一样就行），意思就是内存满了。这个边界就是当n=1n=1n=1或者n=2n=2n=2时函数返回1（其实也可以不用n=2,不过这样减到2时会多算一次），等于0就不用说了，直接告诉main函数调用F函数结束。 让我们来模拟一下这个递归，当我们输入的是4的时候，这时候a1=4a_1=4a1​=4,并不满足前面的条件，所以直接跳进else。但是要算F(4)F(4)F(4)的话得先算出F(3)+F(2)F(3) + F(2)F(3)+F(2)的值，这时候会再次调用F函数，（因为代码是从上而下执行的，所以代码暂时在这里停住了）调用后a2a_2a2​为3,要算F(3)F(3)F(3)就要先算F(2)+F(1)F(2) + F(1)F(2)+F(1),这时候又一次调用了F函数，但这一次不同了因为a3=2a_3=2a3​=2满足a=2a=2a=2这一条件，所以函数直接返回1，然后程序跳转到a2a_2a2​这一层调用中，F(3)=1+F(1)F(3) = 1 + F(1)F(3)=1+F(1),然后继续调用F函数，同样a4=1a_4=1a4​=1满足条件，函数返回1。接着又跳转回a2a_2a2​这一层调用，F(3)=1+1F(3) = 1 + 1F(3)=1+1,算完F(3)F(3)F(3)后继续算F(2)F(2)F(2),同样直接返回1，这样F(3)+F(2)F(3) + F(2)F(3)+F(2)就算完了，函数直接把结果返回给调用者，也就是main函数。在mian函数中输出F(4)F(4)F(4)的结果为3。至此递归就结束了。虽然理解起来挺复杂，但是认真地去模拟一下其实也没有想象的那么难（你以为就这？，不不不，还有更麻烦的递归，这只是最简单的一种）。 递归其实就相当于套娃一样一层一层地往下套，但是它返回结果的时候并不是从最上层开始的，而是从等于边界条件那一层开始逐级往上返回结果。有时候可以利用这一性质逆序输出数据2333。当然也不是递归就得返回数据，视情况而定（快速排序和归并排序的递归算法就不需要返回数据，直接修改数组的值就行了，因为习惯上把数组定义为全局变量，所以不需要数组当作参数传入或者是返回值返回） 但是类似这种递归其实当输入的数字大起来的时候是会重复计算的，所以可以适当优化一下，具体的自行百度~~~ 题解🙆‍♂ 下面给出一些常见的递归题目，也是非常简单的（因为列出数据就可以发现其实就是斐波那契数列。。。）。 1.问题描述：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少对？ 这题通过列出的数据可以发现第一个月只有1对，第二个月也只有1对，第三个月有2对，第四个月有3对，第五个月有5对。。。 所以我们直接用斐波那契数列的代码就行了🤙🤙🤙 #include &lt;iostream&gt; using namespace std; int n; int F(int a) { if(a == 0) return 0; else if(a == 1 || a == 2) return 1; else return F(a - 1) + F(a - 2); } int main() { cin &gt;&gt; n; cout &lt;&lt; F(n) &lt;&lt; endl; return 0; } 2.有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？（这题稍微有点不一样） 输入格式 输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。 输出格式 对于每个测试实例，请输出不同走法的数量 输入样例 2 2 3 输出样例 1 2 这个列出数据也可以发现，第一级的时候为0，第二级的时候为1，第三级的时候为2，第四级的时候为3。。。 所以对于0、1和2我们得处理一下。但是这里已经不可以用递归了，我是这么认为的 从列出的数据中可以发现，n=1n=1n=1时返回0，n=2n=2n=2时返回1，n=3n=3n=3时返回2就行了，n&gt;3n&gt;3n&gt;3时我们可以发现，输入的是4的话只需要加1次就可以得到结果了，5的话要加2次，以此类推，加的次数与输入的数只相差了3，那么我们把输入的数减去3赋值到一个变量中，用来表示我们要加的次数，然后将1与2用另外两个变量存起来，再定义一个变量用于存结果，以便返回。这时候我们只需要用while循环或者for循环即可做出这道题🤣🤣🤣 （其实这种两个变量的做法也可以顶替递归做斐波那契数列的题，思路是一样的） #include&lt;cstdio&gt; //定义常量，类似C中的#define N 100010 //比要求的数据范围多10是为了防止后续的操作导致溢出，反正内存一般是够用的，不差这几个 const int N = 100010 int arr[N]; int n; int F(int a) { int value = 0 , b = 1 , c = 2; if(a == 1) { return value; } else if(a == 2) { value = 1; return value; } else if(a == 3) { value = 2; return value; } else { a -= 3; while( a &gt; 0) -- a , value = b + c , b = c , c = value; return value; } } int main() { scanf(&quot;%d&quot; , &amp;n);//cin &gt;&gt; n; int i = 0 , temp; temp = n; //for(int i = 0; i &lt; n; ++ i) // cin &gt;&gt; a[i]; while(temp --) scanf(&quot;%d&quot; , &amp;arr[i]) , ++ i; int j = 0; //for(int j = 0; j &lt; n; ++ j) // cout &lt;&lt; a[j]; while(n --) printf(&quot;%d\\n&quot;,F(arr[j])) , ++ j; return 0; } 3.你要过河，但是没有桥，只有由一排石头堆成的石头路，你一次只能跨一个石头或者两个石头，求你到第n个石头有多少种走法。(这题也稍微有点不一样) 输入格式 正整数n 输出格式 可能性的个数 输入样例1 1 输出样例1 1 输入样例2 2 输出样例2 2 这题从列出的数据中可以发现，它其实是斐波那契数列往左边移了一位的数列。 所以我们直接上递归即可（不超时的情况下）🙂🙂🙂 #include&lt;iostream&gt; using namespace std; unsigned long long f(unsigned long long a) { if(a == 1) return 1; else if(a == 2) return 2; else return f(a - 1) + f(a - 2); } int main() { unsigned long long n; cin &gt;&gt; n; cout &lt;&lt; f(n); return 0; } 到这里递归就讲得差不多啦，如果还有小伙伴不是很理解的话，可以自行百度找题目去深入理解，或者直接用IDE去调试，调试的过程你就能明白递归的过程是怎样了。当然，还是不懂的话可以来找我击剑哦~~~🤺🤺🤺 那么今天的讲解就到此结束啦，See you again！！！🎉🎉🎉 ","link":"https://solitudealma.github.io/post/recursion/"}]}