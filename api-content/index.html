{"posts":[{"title":"快速排序的介绍以及算法的模板分享","content":"今天我们来讲一下快速排序 那么什么是排序呢？ 百度百科是这么介绍的：快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 也可以看看动态图 它的主要思想是分治法，就是把一个问题分成相互独立的几个规模较小的子问题，然后逐一去解决，最终将得到“母问题的答案”。链接 ==&gt;&gt;分治法 今天我们将采用双指针算法去理解快速排序这一过程，对于双指针算法不太理解的小伙伴可以看看这个介绍 ==&gt;&gt; 算法 | 双指针套路总结 双指针算法基本原理和实践 因为我们是用数组去排序的，所以你只需要知道双指针代表着两个在改变的下标就行了（下标访问本质上也是指针）。 快排的平均时间复杂度为O(nlog2n)O(nlog_2n)O(nlog2​n)，最糟糕的时候是O(n2)O(n^2)O(n2)。 首先我们先给出我们的快排模板 void quick_sort(int q[] , int l , int r) { if(l &gt;= r) return; //表示此区间只有一个数或者没有数 int i = l - 0 , j = r + 1 , x = q[l + r &gt;&gt; 1]; //i为左指针，j为右指针 x为每一次分割区间时选定的比较数 &gt;&gt; 这个是右移运算符，是位运算的一种，将一个整数右移一位表示除以2 while(i &lt; j) { do ++ i; while(q[i] &lt; x); //左指针寻找小于x的数 do -- j; while(q[j] &gt; x); //右指针寻找大于x的数 if(i &lt; j) swap(q[i] &lt; q[j]); //swap函数存在于C++的algorithm头文件中，相当于自己手写的交换变量函数，因为指针停下来的时候可能是穿过，重合这两种情况其中一种，如果未相遇我们就交换指针所指的数，然后直到l&gt;=r循环结束 } //每一次递归之后i、j的相对位置只有两种情况，i==j或者i==j+1 quick_sort(q , l , j) , quick_sort(q , j + 1 , r);//递归处理左右区间，先左，再右（注意划分区间用的是i还是j） } 好了，以上就是我们要用到的快排模板了，一个好的模板能让你快速记忆一个算法，同时它也已经帮我们解决了烦人的边界问题，只需要好好理解记忆即可 快排的三个步骤 确定分界点 q[l] , q[l + r &gt;&gt; 1] , q[r] , 随机 调整区间 保证左边小于等于x，右边大于等于x，x在哪一边都可以 递归处理左右两段 这个模板其实不难理解，函数传入一个含有n个元素的有序或者无序的序列，我们用分治法的思想，首先先确定分界点，因为选取的是l + r &gt;&gt; 1也就是中间元素；而后寻找满足条件的数，直到 l&gt;=rl &gt;= rl&gt;=r ,接着调整区间，将其分为&gt;=x&gt;=x&gt;=x和&lt;=x&lt;=x&lt;=x的两个区间（用j划分，j的左边一定小于等于x，j的右边一定大于等于x）；最后再递归处理左右区间。 如果一个区间只有一个元素，而这个区间又满足小于等于x或者大于等于x这一条件，那么整个合并的区间都是有序的。 一共需要分log2nlog_2nlog2​n次,在第log2nlog_2nlog2​n次时每一个元素都在一个区间里，在那个区间中它是有序的。也是至此递归不再继续，因为区间中只有一个元素（ l&gt;=rl &gt;= rl&gt;=r ），还是不明白的小伙伴可以动手模拟一下，画一下图会清晰很多 一些细节 i , j 指针每次都在区间之外，这是因为我们用了do-while循环，每一次指针都是先+1/-1，再判断，这样可以避免死循环等一些迷之操作（其实一般来说都是先判断再操作，这样的话避免回退操作，这里用do-while循环是为了方便理解） 选取元素的作为比较的值时尽量不要选取左右端点，因为当序列有序时，时间复杂度会退化为O(n2)O(n^2)O(n2) 如果选取右端点，则递归处理的代码为quick_sort(q , l , i - 1) , quick_sort(q , i , r);;如果选的是左端点，则为quick_sort(q , l , j) , quick_sort(q , j + 1 , r);；如果选取中间点，两种都可以哦 一切有关边界问题的算法都建议背模板，因为这是经过n位大佬试验过的，只需要记就行了 如果用的时候无论如何都想不起快排的模板的话，还有一个暴力的方式。1.首先我们先创建a，b两个数组；2.遍历数组q，小于等于x的数放入a中，其他的放入b中；3.将a，b分别排序后，先将a中的元素放入q，再将b中的元素放入q即可 这个算法难点在于调整区间,以j来划分区间的话，在j左边的数都小于等于x，在右边的都大于等于x，其他同理，应该注意你用的是i还是j来划分区间 附上一个简单的快速排序图解 现在我们来写一道模板题 AcWing 785.快速排序 题目描述 给定你一个长度为n的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式 输入共两行，第一行包含整数 n。 第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。 输出格式 输出共一行，包含 n 个整数，表示排好序的数列。 数据范围 1≤n≤1000001≤n≤1000001≤n≤100000 输入样例： 5 3 1 2 4 5 输出样例： 1 2 3 4 5 这时候我们直接套用模板既可 #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int n , a[N]; void quick_sort(int q[] , int l , int r) { if(l &gt;= r) return; int x = q[l + r &gt;&gt; 1] , i = l - 1 , j = r + 1; while(i &lt; j) { do ++ i; while(q[i] &lt; x); do -- j; while(q[j] &gt; x); if(i &lt; j) swap(q[i] , q[j]); } quick_sort(q , l , j) , quick_sort(q , j + 1 , r); } int main() { scanf(&quot;%d&quot; , &amp;n); for(int i = 0; i &lt; n; ++ i) scanf(&quot;%d&quot; , &amp;a[i]); quick_sort(a , 0 , n - 1); for(int j = 0; j &lt; n; ++ j) printf(&quot;%d &quot; , a[j]); return 0; } 大家在学算法的时候，特别是学习一个类型题的模板时可以隔三岔五地去敲了两三遍，当然不用追求和模板一致，因为模板是死的，人是活的，只要知道哪里可以变哪里不可以变，灵活运用即可 最后祝大家学习了算法之后，在刷题时能够游刃有余 ","link":"https://solitudealma.github.io/post/quick_sort/"},{"title":"简单介绍一下递归","content":"今天我们来介绍一下递归😤 什么叫递归呢😩，其实说白了就是函数自己调用自己😲。如果还是不明白的小伙伴可以看看百度是怎么介绍的 =&gt;&gt; What is recursion 我第一次认识到递归是因为斐波那契数列。大致是这样的，有这么一个函数F(n)F(n)F(n)，当n=1n=1n=1或者n=2n=2n=2时F(n)=1F(n)=1F(n)=1,当n&gt;2n&gt;2n&gt;2时，F(n)=F(n−1)+F(n−2)F(n)=F(n-1)+F(n-2)F(n)=F(n−1)+F(n−2)。也就是n&gt;2n&gt;2n&gt;2时后面的每一项都等于前两项之和。 用代码来求第n项的话，可以这么写 #include &lt;iostream&gt; using namespace std; int n; int F(int a) { if(a == 0) return 0; else if(a == 1 || a == 2) return 1; //这两个if是递归结束的条件 else return F(a - 1) + F(a - 2); } int main() { cin &gt;&gt; n; cout &lt;&lt; F(n) &lt;&lt; endl; return 0; } 以上就是这简单的递归算法了。 这个代码并不难理解😏。 #include&lt;iostream&gt;这一头文件是C++新加的流输入输出，不懂的话也没关系，看作是scanf(&quot;%d&quot; , &amp;n);就行; using namespace std;也不难理解，C++将标准库中的标识符都放进了std这一命名空间中，为的是保证在同一命名空间中、相同作用域中任何名字都具有唯一性，即不重名。eg：上述代码中引用了iostream这一头文件里的cin函数，用于输入数据；如果不加上这句话，这时候编译器会提示你cin未定义（error: cin was not declared in this scope），相当于你没有引用头文件吧，emmm~~~（应该是这么理解的，大佬不要捶我）。了解过的同学可能会说直接使用命名空间是不太好的，因为你写的这个代码同样可能被其他代码当作头文件引用，会造成命名重复，应该使用什么就加上什么（std::cin）,但是这只是在做项目的时候才会有这种隐患，做题的时候有且只有一个cpp文件，而且你也不想每用一个就加上std吧2333 剩下的就是F这个函数了，递归其实挺好理解的，首先递归必须要有边界条件，否则将会无限递归下去直到栈满。那么你将收到oj（onlinejudge）的Memory Limit Exceeded（emmm，好像不一定是这个，反正意思一样就行），意思就是内存满了。这个边界就是当n=1n=1n=1或者n=2n=2n=2时函数返回1（其实也可以不用n=2,不过这样减到2时会多算一次），等于0就不用说了，直接告诉main函数调用F函数结束。 让我们来模拟一下这个递归，当我们输入的是4的时候，这时候a1=4a_1=4a1​=4,并不满足前面的条件，所以直接跳进else。但是要算F(4)F(4)F(4)的话得先算出F(3)+F(2)F(3) + F(2)F(3)+F(2)的值，这时候会再次调用F函数，（因为代码是从上而下执行的，所以代码暂时在这里停住了）调用后a2a_2a2​为3,要算F(3)F(3)F(3)就要先算F(2)+F(1)F(2) + F(1)F(2)+F(1),这时候又一次调用了F函数，但这一次不同了因为a3=2a_3=2a3​=2满足a=2a=2a=2这一条件，所以函数直接返回1，然后程序跳转到a2a_2a2​这一层调用中，F(3)=1+F(1)F(3) = 1 + F(1)F(3)=1+F(1),然后继续调用F函数，同样a4=1a_4=1a4​=1满足条件，函数返回1。接着又跳转回a2a_2a2​这一层调用，F(3)=1+1F(3) = 1 + 1F(3)=1+1,算完F(3)F(3)F(3)后继续算F(2)F(2)F(2),同样直接返回1，这样F(3)+F(2)F(3) + F(2)F(3)+F(2)就算完了，函数直接把结果返回给调用者，也就是main函数。在mian函数中输出F(4)F(4)F(4)的结果为3。至此递归就结束了。虽然理解起来挺复杂，但是认真地去模拟一下其实也没有想象的那么难（你以为就这？，不不不，还有更麻烦的递归，这只是最简单的一种）。 递归其实就相当于套娃一样一层一层地往下套，但是它返回结果的时候并不是从最上层开始的，而是从等于边界条件那一层开始逐级往上返回结果。有时候可以利用这一性质逆序输出数据2333。当然也不是递归就得返回数据，视情况而定（快速排序和归并排序的递归算法就不需要返回数据，直接修改数组的值就行了，因为习惯上把数组定义为全局变量，所以不需要数组当作参数传入或者是返回值返回） 但是类似这种递归其实当输入的数字大起来的时候是会重复计算的，所以可以适当优化一下，具体的自行百度~~~ 题解🙆‍♂ 下面给出一些常见的递归题目，也是非常简单的（因为列出数据就可以发现其实就是斐波那契数列。。。）。 1.问题描述：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少对？ 这题通过列出的数据可以发现第一个月只有1对，第二个月也只有1对，第三个月有2对，第四个月有3对，第五个月有5对。。。 所以我们直接用斐波那契数列的代码就行了🤙🤙🤙 #include &lt;iostream&gt; using namespace std; int n; int F(int a) { if(a == 0) return 0; else if(a == 1 || a == 2) return 1; else return F(a - 1) + F(a - 2); } int main() { cin &gt;&gt; n; cout &lt;&lt; F(n) &lt;&lt; endl; return 0; } 2.有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？（这题稍微有点不一样） 输入格式 输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。 输出格式 对于每个测试实例，请输出不同走法的数量 输入样例 2 2 3 输出样例 1 2 这个列出数据也可以发现，第一级的时候为0，第二级的时候为1，第三级的时候为2，第四级的时候为3。。。 所以对于0、1和2我们得处理一下。但是这里已经不可以用递归了，我是这么认为的 从列出的数据中可以发现，n=1n=1n=1时返回0，n=2n=2n=2时返回1，n=3n=3n=3时返回2就行了，n&gt;3n&gt;3n&gt;3时我们可以发现，输入的是4的话只需要加1次就可以得到结果了，5的话要加2次，以此类推，加的次数与输入的数只相差了3，那么我们把输入的数减去3赋值到一个变量中，用来表示我们要加的次数，然后将1与2用另外两个变量存起来，再定义一个变量用于存结果，以便返回。这时候我们只需要用while循环或者for循环即可做出这道题🤣🤣🤣 （其实这种两个变量的做法也可以顶替递归做斐波那契数列的题，思路是一样的） #include&lt;cstdio&gt; //定义常量，类似C中的#define N 100010 //比要求的数据范围多10是为了防止后续的操作导致溢出，反正内存一般是够用的，不差这几个 const int N = 100010 int arr[N]; int n; int F(int a) { int value = 0 , b = 1 , c = 2; if(a == 1) { return value; } else if(a == 2) { value = 1; return value; } else if(a == 3) { value = 2; return value; } else { a -= 3; while( a &gt; 0) -- a , value = b + c , b = c , c = value; return value; } } int main() { scanf(&quot;%d&quot; , &amp;n);//cin &gt;&gt; n; int i = 0 , temp; temp = n; //for(int i = 0; i &lt; n; ++ i) // cin &gt;&gt; a[i]; while(temp --) scanf(&quot;%d&quot; , &amp;arr[i]) , ++ i; int j = 0; //for(int j = 0; j &lt; n; ++ j) // cout &lt;&lt; a[j]; while(n --) printf(&quot;%d\\n&quot;,F(arr[j])) , ++ j; return 0; } 3.你要过河，但是没有桥，只有由一排石头堆成的石头路，你一次只能跨一个石头或者两个石头，求你到第n个石头有多少种走法。(这题也稍微有点不一样) 输入格式 正整数n 输出格式 可能性的个数 输入样例1 1 输出样例1 1 输入样例2 2 输出样例2 2 这题从列出的数据中可以发现，它其实是斐波那契数列往左边移了一位的数列。 所以我们直接上递归即可（不超时的情况下）🙂🙂🙂 #include&lt;iostream&gt; using namespace std; unsigned long long f(unsigned long long a) { if(a == 1) return 1; else if(a == 2) return 2; else return f(a - 1) + f(a - 2); } int main() { unsigned long long n; cin &gt;&gt; n; cout &lt;&lt; f(n); return 0; } 到这里递归就讲得差不多啦，如果还有小伙伴不是很理解的话，可以自行百度找题目去深入理解，或者直接用IDE去调试，调试的过程你就能明白递归的过程是怎样了。当然，还是不懂的话可以来找我击剑哦~~~🤺🤺🤺 那么今天的讲解就到此结束啦，See you again！！！🎉🎉🎉 ","link":"https://solitudealma.github.io/post/recursion/"}]}