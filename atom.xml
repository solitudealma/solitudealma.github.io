<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://solitudealma.github.io</id>
    <title>SolitudeAlma</title>
    <updated>2021-02-14T15:10:22.610Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://solitudealma.github.io"/>
    <link rel="self" href="https://solitudealma.github.io/atom.xml"/>
    <subtitle>都懂一点，不是很懂的小捞仔</subtitle>
    <logo>https://solitudealma.github.io/images/avatar.png</logo>
    <icon>https://solitudealma.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, SolitudeAlma</rights>
    <entry>
        <title type="html"><![CDATA[快速排序的介绍以及算法的模板分享]]></title>
        <id>https://solitudealma.github.io/post/quick_sort/</id>
        <link href="https://solitudealma.github.io/post/quick_sort/">
        </link>
        <updated>2021-02-12T14:57:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="今天我们来讲一下快速排序">今天我们来讲一下快速排序</h3>
<p>那么什么是排序呢？</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/369842?fromtitle=%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&amp;fromid=2084344&amp;fr=aladdin">百度百科</a>是这么介绍的：快速排序由C. A. R. Hoare在1960年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
</blockquote>
<p>它的主要思想是分治法，就是把一个问题分成相互独立的几个规模较小的子问题，然后逐一去解决，最终将得到“母问题的答案”。链接 ==&gt;&gt;<a href="https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95/2407337?fr=aladdin">分治法</a></p>
<p>今天我们将采用双指针算法去理解快速排序这一过程，对于双指针算法不太理解的小伙伴可以看看这个介绍 ==&gt;&gt; <a href="">双指针算法</a></p>
<p>因为我们是用数组去排序的，所以你只需要知道双指针代表着两个在改变的下标就行了（下标访问本质上也是指针）。</p>
<p>快排的平均时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，最糟糕的时候是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>首先我们先给出我们的快排模板</p>
<pre><code class="language-c++">void quick_sort(int q[] , int l , int r)
{
    if(l &gt;= r) return; //表示此区间只有一个数或者没有数

    int i = l - 0 , j = r + 1 , x = q[l + r &gt;&gt; 1]; //i为左指针，j为右指针 x为每一次分割区间时选定的比较数  &gt;&gt; 这个是右移运算符，是位运算的一种，将一个整数右移一位表示除以2 
    while(l &lt; r)
    {
        do ++ i; while(q[i] &lt; x); //左指针寻找小于x的数
        do -- j; while(q[j] &gt; x); //右指针寻找大于x的数
        if(i &lt; j) swap(q[i] &lt; q[j]); //swap函数存在于C++的algorithm头文件中，相当于自己手写的交换变量函数，因为指针停下来的时候可能是穿过，重合这两种情况其中一种，如果未相遇我们就交换指针所指的数，然后直到l&gt;=r循环结束
    }
    //每一次递归之后i、j的相对位置只有两种情况，i==j或者i==j+1
    quick_sort(q , l , j) , quick_sort(q , j + 1 , r);//递归处理左右区间，先左，再右（注意划分区间用的是i还是j）
}
</code></pre>
<p>好了，以上就是我们要用到的快排模板了，一个好的模板能让你快速记忆一个算法，同时它也已经帮我们解决了烦人的边界问题，只需要好好理解记忆即可</p>
<h4 id="快排的三个步骤">快排的三个步骤</h4>
<blockquote>
<ol>
<li>确定分界点 q[l] , q[l + r &gt;&gt; 1] , q[r] , 随机</li>
<li>调整区间 保证左边小于等于x，右边大于等于x，x在哪一边都可以</li>
<li>递归处理左右两段</li>
</ol>
</blockquote>
<p>这个模板其实不难理解，函数传入一个含有n个元素的有序或者无序的序列，我们用分治法的思想，首先先确定分界点，因为选取的是<code>l + r &gt;&gt; 1</code>也就是中间元素；而后寻找满足条件的数，直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>&gt;</mo><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l &gt;= r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> ,接着调整区间，将其分为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&gt;</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">&gt;=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">&lt;=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的两个区间（用j划分，j的左边一定小于等于x，j的右边一定大于等于x）；最后再递归处理左右区间。</p>
<blockquote>
<p>如果一个区间只有一个元素，而这个区间又满足小于等于x或者大于等于x这一条件，那么整个合并的区间都是有序的。</p>
</blockquote>
<p>一共需要分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>次,在第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>次时每一个元素都在一个区间里，在那个区间中它是有序的。也是至此递归不再继续，因为区间中只有一个元素（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mo>&gt;</mo><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l &gt;= r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> ），还是不明白的小伙伴可以动手模拟一下，画一下图会清晰很多</p>
<blockquote>
<p>一些细节</p>
<blockquote>
<ol>
<li>i , j 指针每次都在区间之外，这是因为我们用了do-while循环，每一次指针都是先+1/-1，再判断，这样可以避免死循环等一些迷之操作（其实一般来说都是先判断再操作，这样的话避免回退操作，这里用do-while循环是为了方便理解）</li>
<li>选取元素的作为比较的值时尽量不要选取左右端点，因为当序列有序时，时间复杂度会退化为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>如果选取右端点，则递归处理的代码为<code>quick_sort(q , l , i - 1) , quick_sort(q , i , r);</code>;如果选的是左端点，则为<code>quick_sort(q , l , j) , quick_sort(q , j + 1 , r);</code>；如果选取中间点，两种都可以哦</li>
<li>一切有关边界问题的算法都建议背模板，因为这是经过n位大佬试验过的，只需要记就行了</li>
<li>如果用的时候无论如何都想不起快排的模板的话，还有一个暴力的方式。1.首先我们先创建a，b两个数组；2.遍历数组q，小于等于x的数放入a中，其他的放入b中；3.将a，b分别排序后，先将a中的元素放入q，再将b中的元素放入q即可</li>
</ol>
</blockquote>
</blockquote>
<p>这个算法难点在于调整区间,以j来划分区间的话，在j左边的数都小于等于x，在右边的都大于等于x，其他同理，应该注意你用的是i还是j来划分区间</p>
<h4 id="附上一个简单的快速排序图解"><a href="">附上一个简单的快速排序图解</a></h4>
<p>现在我们来写一道模板题</p>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/787/">AcWing 785.快速排序</a></p>
</blockquote>
<h4 id="题目描述">题目描述</h4>
<p>给定你一个长度为n的整数数列。</p>
<p>请你使用快速排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<h4 id="输入格式">输入格式</h4>
<p>输入共两行，第一行包含整数 n。</p>
<p>第二行包含 n 个整数（所有整数均在1~109范围内），表示整个数列。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出共一行，包含 n 个整数，表示排好序的数列。</p>
<h4 id="数据范围">数据范围</h4>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100000</mn></mrow><annotation encoding="application/x-tex">1≤n≤100000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></p>
<h4 id="输入样例">输入样例：</h4>
<pre><code>5

3 1 2 4 5
</code></pre>
<h4 id="输出样例">输出样例：</h4>
<pre><code>1 2 3 4 5
</code></pre>
<p>这时候我们直接套用模板既可</p>
<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 100010;

int n , a[N];

void quick_sort(int q[] , int l , int r)
{
    if(l &gt;= r) return;

    int x = q[l + r &gt;&gt; 1] , i = l - 1 , j = r + 1;
    while(l &lt; r)
    {
        do ++ i; while(q[i] &lt; x);
        do -- j; while(q[j] &gt; x);
        if(i &lt; j) swap(q[i] , q[j]);
    }
    qucik_sort(q , l , j) , quick_sort(q , j + 1 , r);
}

int main()
{
    scanf(&quot;%d&quot; , &amp;n);

    for(int i = 0; i &lt; n; ++ i)
        scanf(&quot;%d&quot; , a[i]);

    quick_sort(a , 0 , n - 1);

    for(int j = 0; j &lt; n; ++ j)
        printf(&quot;%d &quot; , a[j]);

    return 0;
}

</code></pre>
<p>大家在学算法的时候，特别是学习一个类型题的模板时可以隔三岔五地去敲了两三遍，当然不用追求和模板一致，因为模板是死的，人是活的，只要知道哪里可以变哪里不可以变，灵活运用即可</p>
<p>最后祝大家学习了算法之后，在刷题时能够游刃有余</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单介绍一下递归]]></title>
        <id>https://solitudealma.github.io/post/recursion/</id>
        <link href="https://solitudealma.github.io/post/recursion/">
        </link>
        <updated>2021-02-12T14:13:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="今天我们来介绍一下递归">今天我们来介绍一下递归😤</h3>
<hr>
<h4 id="什么叫递归呢其实说白了就是函数自己调用自己-如果还是不明白的小伙伴可以看看百度是怎么介绍的-what-is-recursion">什么叫递归呢😩，其实说白了就是函数自己调用自己😲。如果还是不明白的小伙伴可以看看百度是怎么介绍的 =&gt;&gt; <a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695?fr=aladdin">What is recursion</a></h4>
<p>我第一次认识到递归是因为斐波那契数列。大致是这样的，有这么一个函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(n)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n&gt;2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)=F(n-1)+F(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>。也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n&gt;2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时后面的每一项都等于前两项之和。</p>
<p>用代码来求第n项的话，可以这么写</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

int n;

int F(int a)
{
    if(a == 0) return 0;
    else if(a == 1 || a == 2) return 1; //这两个if是递归结束的条件
    else return F(a - 1) + F(a - 2);
}

int main()
{
    cin &gt;&gt; n;

    cout &lt;&lt; F(n) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>以上就是这简单的递归算法了。<br>
这个代码并不难理解😏。</p>
<ol>
<li>
<blockquote>
<p><code>#include&lt;iostream&gt;</code>这一头文件是C++新加的流输入输出，不懂的话也没关系，看作是<code>scanf(&quot;%d&quot; , &amp;n);</code>就行;</p>
</blockquote>
</li>
<li>
<blockquote>
<p>using namespace std;也不难理解，C++将标准库中的标识符都放进了std这一命名空间中，为的是保证在同一命名空间中、相同作用域中任何名字都具有唯一性，即不重名。eg：上述代码中引用了iostream这一头文件里的cin函数，用于输入数据；如果不加上这句话，这时候编译器会提示你cin未定义（error: cin was not declared in this scope），相当于你没有引用头文件吧，emmm~~~（应该是这么理解的，大佬不要捶我）。了解过的同学可能会说直接使用命名空间是不太好的，因为你写的这个代码同样可能被其他代码当作头文件引用，会造成命名重复，应该使用什么就加上什么（std::cin）,但是这只是在做项目的时候才会有这种隐患，做题的时候有且只有一个cpp文件，而且你也不想每用一个就加上std吧2333</p>
</blockquote>
</li>
<li>
<blockquote>
<p>剩下的就是F这个函数了，递归其实挺好理解的，首先递归必须要有边界条件，否则将会无限递归下去直到栈满。那么你将收到oj（onlinejudge）的Memory Limit Exceeded（emmm，好像不一定是这个，反正意思一样就行），意思就是内存满了。这个边界就是当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时函数返回1（其实也可以不用n=2,不过这样减到2时会多算一次），等于0就不用说了，直接告诉main函数调用F函数结束。</p>
<blockquote>
<p>让我们来模拟一下这个递归，当我们输入的是4的时候，这时候<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">a_1=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>,并不满足前面的条件，所以直接跳进else。但是要算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span>的话得先算出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(3) + F(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>的值，这时候会再次调用F函数，（因为代码是从上而下执行的，所以代码暂时在这里停住了）调用后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为3,要算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span>就要先算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(2) + F(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>,这时候又一次调用了F函数，但这一次不同了因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>3</mn></msub><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a_3=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>这一条件，所以函数直接返回1，然后程序跳转到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>这一层调用中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mi>F</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(3) = 1 + F(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>,然后继续调用F函数，同样<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>4</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a_4=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>满足条件，函数返回1。接着又跳转回<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>这一层调用，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(3) = 1 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,算完<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span>后继续算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>,同样直接返回1，这样<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(3) + F(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>就算完了，函数直接把结果返回给调用者，也就是main函数。在mian函数中输出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span></span></span></span>的结果为3。至此递归就结束了。虽然理解起来挺复杂，但是认真地去模拟一下其实也没有想象的那么难（<s>你以为就这？，不不不，还有更麻烦的递归，这只是最简单的一种</s>）。</p>
</blockquote>
</blockquote>
</li>
<li>
<blockquote>
<p>递归其实就相当于套娃一样一层一层地往下套，但是它返回结果的时候并不是从最上层开始的，而是从等于边界条件那一层开始逐级往上返回结果。有时候可以利用这一性质逆序输出数据2333。当然也不是递归就得返回数据，视情况而定（快速排序和归并排序的递归算法就不需要返回数据，直接修改数组的值就行了，因为习惯上把数组定义为全局变量，所以不需要数组当作参数传入或者是返回值返回）</p>
</blockquote>
</li>
</ol>
<p>但是类似这种递归其实当输入的数字大起来的时候是会重复计算的，所以可以适当优化一下，具体的自行百度~~~</p>
<hr>
<h3 id="题解">题解🙆‍♂</h3>
<p>下面给出一些常见的递归题目，也是非常简单的（因为列出数据就可以发现其实就是斐波那契数列。。。）。</p>
<p>1.问题描述：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少对？</p>
<p>这题通过列出的数据可以发现第一个月只有1对，第二个月也只有1对，第三个月有2对，第四个月有3对，第五个月有5对。。。<br>
所以我们直接用斐波那契数列的代码就行了🤙🤙🤙</p>
<pre><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

int n;

int F(int a)
{
    if(a == 0) return 0;
    else if(a == 1 || a == 2) return 1;
    else return F(a - 1) + F(a - 2);
}

int main()
{
    cin &gt;&gt; n;

    cout &lt;&lt; F(n) &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>2.有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？（这题稍微有点不一样）</p>
<h4 id="输入格式">输入格式</h4>
<p>输入数据首先包含一个整数N，表示测试实例的个数，然后是N行数据，每行包含一个整数M（1&lt;=M&lt;=40）,表示楼梯的级数。</p>
<h4 id="输出格式">输出格式</h4>
<p>对于每个测试实例，请输出不同走法的数量</p>
<h4 id="输入样例">输入样例</h4>
<pre><code>2
2
3
</code></pre>
<h4 id="输出样例">输出样例</h4>
<pre><code>1
2
</code></pre>
<blockquote>
<p>这个列出数据也可以发现，第一级的时候为0，第二级的时候为1，第三级的时候为2，第四级的时候为3。。。<br>
所以对于0、1和2我们得处理一下。但是这里已经不可以用递归了，我是这么认为的</p>
<blockquote>
<p>从列出的数据中可以发现，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时返回0，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>时返回1，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>时返回2就行了，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n&gt;3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>时我们可以发现，输入的是4的话只需要加1次就可以得到结果了，5的话要加2次，以此类推，加的次数与输入的数只相差了3，那么我们把输入的数减去3赋值到一个变量中，用来表示我们要加的次数，然后将1与2用另外两个变量存起来，再定义一个变量用于存结果，以便返回。这时候我们只需要用while循环或者for循环即可做出这道题🤣🤣🤣<br>
（其实这种两个变量的做法也可以顶替递归做斐波那契数列的题，思路是一样的）</p>
</blockquote>
</blockquote>
<pre><code class="language-c++">#include&lt;cstdio&gt;

//定义常量，类似C中的#define N 100010
//比要求的数据范围多10是为了防止后续的操作导致溢出，反正内存一般是够用的，不差这几个
const int  N = 100010

int arr[N];
int n;

int F(int a)
{
    int value = 0 , b = 1 , c = 2;
    if(a == 1)
    {
        return value;
    }
    else if(a == 2)
    {
        value = 1;
        return value;
    }
    else if(a == 3)
    {
        value = 2;
        return value;
    }
    else
    {
        a -= 3;
        while( a &gt; 0) -- a , value = b + c , b = c , c = value;
        return value;
    }
}

int main()
{
    scanf(&quot;%d&quot; , &amp;n);//cin &gt;&gt; n;
    int i = 0 , temp;
    temp = n;
    //for(int i = 0; i &lt; n; ++ i)
    //  cin &gt;&gt; a[i];
    while(temp --) scanf(&quot;%d&quot; , &amp;arr[i]) , ++ i;
    
    int j = 0;
    //for(int j = 0; j &lt; n; ++ j)
    //  cout &lt;&lt; a[j];
    while(n --) printf(&quot;%d\n&quot;,F(arr[j])) , ++ j;
    
    return 0;
}
</code></pre>
<p>3.你要过河，但是没有桥，只有由一排石头堆成的石头路，你一次只能跨一个石头或者两个石头，求你到第n个石头有多少种走法。(这题也稍微有点不一样)</p>
<h4 id="输入格式-2">输入格式</h4>
<p>正整数n</p>
<h4 id="输出格式-2">输出格式</h4>
<p>可能性的个数</p>
<h4 id="输入样例1">输入样例1</h4>
<pre><code>1
</code></pre>
<h4 id="输出样例1">输出样例1</h4>
<pre><code>1
</code></pre>
<h4 id="输入样例2">输入样例2</h4>
<pre><code>2
</code></pre>
<h4 id="输出样例2">输出样例2</h4>
<pre><code>2
</code></pre>
<blockquote>
<p>这题从列出的数据中可以发现，它其实是斐波那契数列往左边移了一位的数列。</p>
<blockquote>
<p>所以我们直接上递归即可（不超时的情况下）🙂🙂🙂</p>
</blockquote>
</blockquote>
<pre><code class="language-c++">#include&lt;iostream&gt;

using namespace std;

unsigned long long f(unsigned long long a)
{
    if(a == 1) return 1;
    else if(a == 2) return 2;
    else
        return f(a - 1) + f(a - 2);
}
int main()
{
    unsigned long long n;
    cin &gt;&gt; n;
    cout &lt;&lt; f(n);
    
    return 0;
}
</code></pre>
<p>到这里递归就讲得差不多啦，如果还有小伙伴不是很理解的话，可以自行百度找题目去深入理解，或者直接用IDE去调试，调试的过程你就能明白递归的过程是怎样了。当然，还是不懂的话可以来找我击剑哦~~~🤺🤺🤺</p>
<p>那么今天的讲解就到此结束啦，See you again！！！🎉🎉🎉</p>
]]></content>
    </entry>
</feed>